[{"content":"The decorator pattern is a design pattern in programming that allows behavior to be added to individual objects, either statically or dynamically, without affecting the behavior of other objects from the same class.\nIn real world, imagine we are decorating a plain Christmas tree. We start with a simple tree, and we add decorations to it such as lights, ornaments, and tinsel. Each decoration enhances the tree by adding a layer of detail without changing its structure. We can add or remove decorations freely without affecting the underlying tree.\nSimilarly, in programming, the decorator pattern is used to \u0026ldquo;decorate\u0026rdquo; objects with additional features or behaviors without changing the object\u0026rsquo;s class. Each decorator adds some functionality, wrapping the original object, just like ornaments wrapping the tree.\nLet\u0026rsquo;s understand this with an example:\nclass Car: def __init__(self): self._description = \u0026#34;Basic Car\u0026#34; def get_description(self): return self._description def get_cost(self): # Cost of the basic car return 10000 Now, let\u0026rsquo;s define some decorators to add features to the car:\nclass PremiumPackageDecorator: def __init__(self, car): self._car = car def get_description(self): return self._car.get_description() + \u0026#34;, with premium package\u0026#34; def get_cost(self): return self._car.get_cost() + 5000 class SportsPackageDecorator: def __init__(self, car): self._car = car def get_description(self): return self._car.get_description() + \u0026#34;, with sports package\u0026#34; def get_cost(self): return self._car.get_cost() + 7000 # Create a basic car my_car = Car() print(my_car.get_description()) print(my_car.get_cost()) # Add premium package my_car = PremiumPackageDecorator(my_car) print(my_car.get_description()) print(my_car.get_cost()) # Add sports package my_car = SportsPackageDecorator(my_car) print(my_car.get_description()) print(my_car.get_cost()) Output:\nBasic Car 10000 Basic Car, with premium package 15000 Basic Car, with premium package, with sports package 22000 In python we have \u0026ldquo;@\u0026rdquo; decorators that we can use on functions.\ndef basic_car_description(): \u0026#34;\u0026#34;\u0026#34;A simple function that returns a basic car\u0026#39;s description.\u0026#34;\u0026#34;\u0026#34; return \u0026#34;Basic Car\u0026#34; def basic_car_cost(): \u0026#34;\u0026#34;\u0026#34;A simple function that returns a basic car\u0026#39;s cost.\u0026#34;\u0026#34;\u0026#34; return 10000 def premium_package(func): \u0026#34;\u0026#34;\u0026#34;Decorator function to add premium package features to a car\u0026#39;s description.\u0026#34;\u0026#34;\u0026#34; def wrapper(*args, **kwargs): return func(*args, **kwargs) + \u0026#34;, with premium package\u0026#34; return wrapper def sports_package(func): \u0026#34;\u0026#34;\u0026#34;Decorator function to add sports package features to a car\u0026#39;s description.\u0026#34;\u0026#34;\u0026#34; def wrapper(*args, **kwargs): return func(*args, **kwargs) + \u0026#34;, with sports package\u0026#34; return wrapper def additional_cost(amount): \u0026#34;\u0026#34;\u0026#34;Decorator function to add additional cost to a car.\u0026#34;\u0026#34;\u0026#34; def decorator(func): def wrapper(*args, **kwargs): return func(*args, **kwargs) + amount return wrapper return decorator # Decorating the functions @premium_package def get_premium_car_description(): return basic_car_description() @additional_cost(5000) def get_premium_car_cost(): return basic_car_cost() @premium_package @sports_package def get_sports_premium_car_description(): return basic_car_description() @additional_cost(12000) def get_sports_premium_car_cost(): return basic_car_cost() print(get_premium_car_description()) print(get_premium_car_cost()) print(get_sports_premium_car_description()) print(get_sports_premium_car_cost()) Output:\nBasic Car, with premium package 15000 Basic Car, with sports package, with premium package 22000 ","permalink":"https://sukhdeepg.github.io/posts/decorator/","summary":"The decorator pattern is a design pattern in programming that allows behavior to be added to individual objects, either statically or dynamically, without affecting the behavior of other objects from the same class.\nIn real world, imagine we are decorating a plain Christmas tree. We start with a simple tree, and we add decorations to it such as lights, ornaments, and tinsel. Each decoration enhances the tree by adding a layer of detail without changing its structure.","title":"Decorator with examples in Python"},{"content":"The Composite Design Pattern is a structural design pattern that lets us compose objects into tree structures to represent part-whole hierarchies. To expand this further: This pattern is all about creating objects that have other objects inside them. Let\u0026rsquo;s break down the last sentence further:\nCompose objects into tree structures: This means that we\u0026rsquo;re making some objects that contain other objects. This is similar to how a family tree works: a parent can have children, and those children can also be parents to their own children. In computer science, this is referred to as a \u0026ldquo;tree\u0026rdquo; structure.\nTo represent part-whole hierarchies: This means that the objects that are inside other objects are considered part of the larger object. It\u0026rsquo;s a way to represent a hierarchy or relationship between things. Like in a car, an engine, wheels, and a body are parts of the car as a whole. The car is the \u0026ldquo;whole\u0026rdquo;, and the engine, wheels, and body are the \u0026ldquo;parts\u0026rdquo;.\nSo in simple terms, the Composite Design Pattern is a way to make complex objects that are made up of other smaller objects, and this pattern allows us to organize these objects in a way that represents a hierarchy or relationship between them.\nLet\u0026rsquo;s understand this with an example:\nfrom abc import ABC, abstractmethod from typing import List class CarComponent(ABC): @abstractmethod def operation(self) -\u0026gt; str: pass class LeafElement(CarComponent): def __init__(self, name): self.name = name def operation(self) -\u0026gt; str: return self.name class Composite(CarComponent): def __init__(self, name) -\u0026gt; None: self.name = name self._children: List[CarComponent] = [] def add(self, component: CarComponent) -\u0026gt; None: self._children.append(component) def remove(self, component: CarComponent) -\u0026gt; None: self._children.remove(component) def operation(self) -\u0026gt; str: results = [] for child in self._children: results.append(child.operation()) return f\u0026#34;{self.name}: {\u0026#39;, \u0026#39;.join(results)}\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: # simple components engine = LeafElement(\u0026#34;Engine\u0026#34;) wheel1 = LeafElement(\u0026#34;Wheel1\u0026#34;) wheel2 = LeafElement(\u0026#34;Wheel2\u0026#34;) wheel3 = LeafElement(\u0026#34;Wheel3\u0026#34;) wheel4 = LeafElement(\u0026#34;Wheel4\u0026#34;) # complex components (composite) wheels = Composite(\u0026#34;Wheels\u0026#34;) car = Composite(\u0026#34;Car\u0026#34;) # tree structure wheels.add(wheel1) wheels.add(wheel2) wheels.add(wheel3) wheels.add(wheel4) car.add(engine) car.add(wheels) print(car.operation()) Output:\nCar: Engine, Wheels: Wheel1, Wheel2, Wheel3, Wheel4 Some real world scenarios where this design pattern can be used:\nFile Systems: A file system is a classic example of a Composite pattern. A directory can contain files or other directories. Here, \u0026lsquo;Directory\u0026rsquo; is a Composite, and \u0026lsquo;File\u0026rsquo; is a Leaf. GUI Widgets: In graphical applications, a container widget (like a window or a panel) can contain other widgets (like buttons and checkboxes) or even other containers. This is another case where the Composite pattern is useful. Hope the post have created some value. Peace!\n","permalink":"https://sukhdeepg.github.io/posts/composite/","summary":"The Composite Design Pattern is a structural design pattern that lets us compose objects into tree structures to represent part-whole hierarchies. To expand this further: This pattern is all about creating objects that have other objects inside them. Let\u0026rsquo;s break down the last sentence further:\nCompose objects into tree structures: This means that we\u0026rsquo;re making some objects that contain other objects. This is similar to how a family tree works: a parent can have children, and those children can also be parents to their own children.","title":"Composite with examples in Python"},{"content":"The Bridge Design Pattern is a structural design pattern that aims to separate what a system does from how it does it, so we can change the \u0026lsquo;what\u0026rsquo; and the \u0026lsquo;how\u0026rsquo; independently.\nIn other words, it organizes code in a way that lets us modify the operations a system can perform (like starting a car engine), and the details of how those operations are performed (like whether it\u0026rsquo;s a petrol or electric engine), separately. This makes the code easier to update and manage.\nIt\u0026rsquo;s helpful when we have a monolithic class and we want to divide it further to simplify maintenance.\nImagine that there are two dimensions: \u0026ldquo;car type\u0026rdquo; and \u0026ldquo;car engine type\u0026rdquo;. If we want to create classes for every possible combination, there will be quite a few (sedan with petrol engine, sedan with electric engine, SUV with petrol engine, SUV with electric engine, etc.). Instead, we can separate these two dimensions into different class hierarchies, and then combine them - effectively \u0026ldquo;building a bridge\u0026rdquo; between \u0026ldquo;car type\u0026rdquo; and \u0026ldquo;car engine type\u0026rdquo;.\nLet\u0026rsquo;s understand this with an example:\nfrom abc import ABC, abstractmethod class Engine(ABC): @abstractmethod def start_engine(self): pass class PetrolEngine(Engine): def start_engine(self): return \u0026#34;Starting the petrol engine\u0026#34; class ElectricEngine(Engine): def start_engine(self): return \u0026#34;Starting the electric engine\u0026#34; class Car(ABC): def __init__(self, engine: Engine): self._engine = engine @abstractmethod def start_car(self): pass class Sedan(Car): def start_car(self): return f\u0026#34;Sedan: {self._engine.start_engine()}\u0026#34; class SUV(Car): def start_car(self): return f\u0026#34;SUV: {self._engine.start_engine()}\u0026#34; sedan_with_petrol_engine = Sedan(PetrolEngine()) suv_with_electric_engine = SUV(ElectricEngine()) print(sedan_with_petrol_engine.start_car()) print(suv_with_electric_engine.start_car()) Output:\nSedan: Starting the petrol engine SUV: Starting the electric engine In this code, Car and Engine are the two dimensions. Car is the \u0026lsquo;abstraction\u0026rsquo; and Engine is the \u0026lsquo;implementation\u0026rsquo;. This way, adding a new car type or a new engine type does not affect each other.\nThe Bridge Design Pattern is handy in many scenarios where we want to keep the high-level operations in a system separate from the low-level details. This pattern is used in GUI systems to support multiple operating systems, in software to communicate using different protocols with hardware devices, in database interactions to support various types of databases, and in media players to decode different file formats. Essentially, the Bridge pattern is about segregating \u0026ldquo;what\u0026rdquo; a system does from \u0026ldquo;how\u0026rdquo; it does it, allowing both to evolve independently.\nHope the post have created some value. Peace!\n","permalink":"https://sukhdeepg.github.io/posts/bridge/","summary":"The Bridge Design Pattern is a structural design pattern that aims to separate what a system does from how it does it, so we can change the \u0026lsquo;what\u0026rsquo; and the \u0026lsquo;how\u0026rsquo; independently.\nIn other words, it organizes code in a way that lets us modify the operations a system can perform (like starting a car engine), and the details of how those operations are performed (like whether it\u0026rsquo;s a petrol or electric engine), separately.","title":"Bridge with examples in Python"},{"content":"The adapter design pattern is a structural design pattern that allows objects that don\u0026rsquo;t initially know how to interact with each other (due to differences in their communication methods) to still cooperate. This pattern introduces a wrapper class (an \u0026ldquo;adapter\u0026rdquo;) which translates the interface of one class into an interface expected by clients.\nIn real world, when one of our electrical appliance has a plug that won\u0026rsquo;t fit in the socket due to the appliance having different norm than the other appliances, we make use of an adapter to overcome this and use the appliance. Here, this adapter is the adapter pattern.\nLet\u0026rsquo;s understand this with an example:\nclass Car: def __init__(self, model): self.model = model def start_engine(self): return f\u0026#34;{self.model}\u0026#39;s engine started.\u0026#34; def refuel(self): return f\u0026#34;Refuelling {self.model}.\u0026#34; Here, we have an ElectricCar with different interface than the Car:\nclass ElectricCar: def __init__(self, model): self.model = model def start_electric_engine(self): return f\u0026#34;{self.model}\u0026#39;s electric engine started.\u0026#34; def recharge_battery(self): return f\u0026#34;Recharging {self.model}.\u0026#34; Our existing system doesn\u0026rsquo;t know how to interact with ElectricCar object as it only knows how to work with Car object. To solve this, we\u0026rsquo;ll use the Adapter design pattern.\nLet\u0026rsquo;s create an ElectricCarAdapter because here we can see that Car and ElectricCar have similar purpose.\nclass ElectricCarAdapter: def __init__(self, electric_car): self.electric_car = electric_car def start_engine(self): return self.electric_car.start_electric_engine() def refuel(self): return self.electric_car.recharge_battery() Now, we can use ElectricCar object in the existing system similar to Car object.\ndef client_code(car): print(car.start_engine()) print(car.refuel()) if __name__ == \u0026#34;__main__\u0026#34;: my_car = Car(\u0026#34;PetrolCar\u0026#34;) client_code(my_car) my_electric_car = ElectricCarAdapter(ElectricCar(\u0026#34;ModernEV\u0026#34;)) client_code(my_electric_car) Output:\nPetrolCar\u0026#39;s engine started. Refuelling PetrolCar. ModernEV\u0026#39;s electric engine started. Recharging ModernEV. Here, we saw that how Adapter pattern can enable code to work with classes that otherwise wouldn\u0026rsquo;t be compatible due to their interfaces.\nSome real world scenarios where Adapter pattern could be used:\nLegacy and modern systems: When there is a need to integrate our modern system with a very old legacy system where rewritting the complete legacy system is not feasible, we can use the Adapter pattern to create an interface to enable interaction between legacy and modern systems.\nWorking with Third-Party libraries: Sometimes, a library has an interface that doesn’t match our system’s interface. An adapter class can help translate the interface of the third-party library to the interface our system expects.\nHope the post have created some value. Peace!\n","permalink":"https://sukhdeepg.github.io/posts/adapter/","summary":"The adapter design pattern is a structural design pattern that allows objects that don\u0026rsquo;t initially know how to interact with each other (due to differences in their communication methods) to still cooperate. This pattern introduces a wrapper class (an \u0026ldquo;adapter\u0026rdquo;) which translates the interface of one class into an interface expected by clients.\nIn real world, when one of our electrical appliance has a plug that won\u0026rsquo;t fit in the socket due to the appliance having different norm than the other appliances, we make use of an adapter to overcome this and use the appliance.","title":"Adapter with examples in Python"},{"content":"Singleton design pattern is a type of creational pattern which we use when we need to provide global access to an object. Basically, a class will only have one object.\nLet\u0026rsquo;s understand the above with an example:\nclass Singleton(type): _instances = {} def __call__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls] = super().__call__(*args, **kwargs) return cls._instances[cls] class Car(metaclass=Singleton): def __init__(self, make, model, year): self.make = make self.model = model self.year = year car1 = Car(\u0026#34;Company1\u0026#34;, \u0026#34;Car1\u0026#34;, 2023) car2 = Car(\u0026#34;Company2\u0026#34;, \u0026#34;Car2\u0026#34;, 2023) print(car1 is car2) Output:\nTrue Here, Singleton is a metaclass that ensures that we only ever create one instance of Car. When we call Car() to create an instance, the call method of the metaclass is invoked. If an instance of Car doesn\u0026rsquo;t exist, it creates one and stores it in _instances. If it already exists, it returns the existing one.\nPractical applications of Singleton design pattern includes creating object for logging, DB connection, shared resources (e.g. class having a counter), etc. This helps us ensure consistency.\nHope the post have created some value. Peace!\n","permalink":"https://sukhdeepg.github.io/posts/singleton/","summary":"Singleton design pattern is a type of creational pattern which we use when we need to provide global access to an object. Basically, a class will only have one object.\nLet\u0026rsquo;s understand the above with an example:\nclass Singleton(type): _instances = {} def __call__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls] = super().__call__(*args, **kwargs) return cls._instances[cls] class Car(metaclass=Singleton): def __init__(self, make, model, year): self.make = make self.model = model self.","title":"Singleton with examples in Python"},{"content":"The Prototype Design Pattern is a creational design pattern that involves duplicating or \u0026ldquo;cloning\u0026rdquo; existing objects to create new ones, rather than creating new objects from scratch. This is useful when object creation is time-consuming or complex. This means, instead of creating a new object and setting it up, we make a copy of an existing object and modify it as needed.\nLet\u0026rsquo;s understand the above with an example:\nimport copy class Car: def __init__(self, model, color, engine): self.model = model self.color = color self.engine = engine def clone(self): return copy.deepcopy(self) def __str__(self): return f\u0026#39;{self.color} {self.model} with a {self.engine} engine\u0026#39; if __name__ == \u0026#34;__main__\u0026#34;: car1 = Car(\u0026#39;car1\u0026#39;, \u0026#39;red\u0026#39;, \u0026#39;electric\u0026#39;) print(car1) car2 = car1.clone() car2.model = \u0026#39;car2\u0026#39; car2.color = \u0026#39;blue\u0026#39; print(car2) Output:\nred car1 with a electric engine blue car2 with a electric engine In the above example, we first create a Car object from scratch, i.e., car1 has a red color and electric engine. Now, we need a similar Car object that has a different model and color. So, instead of creating the car2 object from scratch, we just make a copy of the car1 object and make the modifications. In this case, car1 is the prototype for car2.\nBut, why do we need to clone an object? we can always create a new object right?\nIn most cases, creating a new object is the straightforward approach. However, Prototype pattern is useful when creating a new object is resource-intensive, such as when it requires a significant amount of computation, disk reads, network calls, etc. Also when we have an object in a certain state and we need another object just like it.\nHope the post have created some value. Peace!\n","permalink":"https://sukhdeepg.github.io/posts/prototype/","summary":"The Prototype Design Pattern is a creational design pattern that involves duplicating or \u0026ldquo;cloning\u0026rdquo; existing objects to create new ones, rather than creating new objects from scratch. This is useful when object creation is time-consuming or complex. This means, instead of creating a new object and setting it up, we make a copy of an existing object and modify it as needed.\nLet\u0026rsquo;s understand the above with an example:\nimport copy class Car: def __init__(self, model, color, engine): self.","title":"Prototype with examples in Python"},{"content":"The Builder design pattern is a method for constructing complex objects step-by-step, allowing you to create different configurations or variations of the object without altering the main class representing the object. It simplifies object creation by providing a clear and flexible way to build objects with multiple options or components.\nLet\u0026rsquo;s understand the above with an example:\nclass CarBuilder: def __init__(self): self.car = Car() def set_wheels(self, wheels): self.car.wheels = wheels return self def set_color(self, color): self.car.color = color return self def set_seats(self, seats): self.car.seats = seats return self def build(self): return self.car class Car: def __init__(self): self.wheels = None self.color = None self.seats = None def __str__(self): return f\u0026#34;Car with {self.wheels} wheels, {self.color} color, and {self.seats} seats.\u0026#34; builder = CarBuilder() builder.set_wheels(4) builder.set_color(\u0026#34;blue\u0026#34;) builder.set_seats(4) car = builder.build() print(car) The output:\nCar with 4 wheels, blue color, and 4 seats. Here, CarBuilder is responsible for building the Car object. It will set the number of wheels, color and number of seats. The build method will return the final object.\nBut, why do we need the CarBuilder here? We can just put all of this in the Car class itself. The builder pattern becomes useful in cases where the Car class has many optional or complex configurations. So, instead of creating multiple subclasses or sending multiple variables in the constructor, the CarBuilder way is more easy to read and maintain.\nHope the post have created some value. Peace!\n","permalink":"https://sukhdeepg.github.io/posts/builder/","summary":"The Builder design pattern is a method for constructing complex objects step-by-step, allowing you to create different configurations or variations of the object without altering the main class representing the object. It simplifies object creation by providing a clear and flexible way to build objects with multiple options or components.\nLet\u0026rsquo;s understand the above with an example:\nclass CarBuilder: def __init__(self): self.car = Car() def set_wheels(self, wheels): self.car.wheels = wheels return self def set_color(self, color): self.","title":"Builder with examples in Python"},{"content":"Abstract Factory is a creational design pattern that helps create groups of related objects without knowing their specific classes. It\u0026rsquo;s particularly useful when we need to create objects that belong to a family, but we don\u0026rsquo;t care about the specific implementation.\nFirst, let\u0026rsquo;s understand create groups of related objects without knowing their specific classes with a small example:\nclass ShapeFactory: def create_shape(self, shape_type): if shape_type == \u0026#39;circle\u0026#39;: return Circle() elif shape_type == \u0026#39;square\u0026#39;: return Square() elif shape_type == \u0026#39;triangle\u0026#39;: return Triangle() factory = ShapeFactory() shape1 = factory.create_shape(\u0026#39;circle\u0026#39;) shape2 = factory.create_shape(\u0026#39;square\u0026#39;) Here, ShapeFactory creates related shape objects (circles, squares, triangles) without needing to know their specific classes, as it relies on the shape_type parameter.\nThe statement when we need to create objects that belong to a family, but we don\u0026rsquo;t care about the specific implementation simply means that we want to create objects that share a common behavior, without focusing on the details of how they\u0026rsquo;re built. Let\u0026rsquo;s see a small example:\nclass Shape(ABC): @abstractmethod def draw(self): pass class Circle(Shape): def draw(self): return \u0026#34;Drawing a circle\u0026#34; class Square(Shape): def draw(self): return \u0026#34;Drawing a square\u0026#34; Here, we\u0026rsquo;re creating shapes that belong to the Shape family. We don\u0026rsquo;t care about the specific implementation (e.g., how the circle or square is drawn) but we care about the common interface (the draw method). The ShapeFactory creates the objects, and we can use them without knowing their details:\nfactory = ShapeFactory() shape1 = factory.create_shape(\u0026#39;circle\u0026#39;) shape2 = factory.create_shape(\u0026#39;square\u0026#39;) shape1.draw() # Output: Drawing a circle shape2.draw() # Output: Drawing a square One can create and use shapes without knowing their specific classes or implementations, focusing on their shared behavior through the Shape interface.\nNow, let\u0026rsquo;s understand everything together with the following example:\nfrom abc import ABC from abc import abstractmethod class Engine(ABC): @abstractmethod def description(self): pass class Car(ABC): @abstractmethod def assemble(self): pass Concrete classes for Hybrid, Electric, and Gasoline engines:\nclass HybridEngine(Engine): def description(self): return \u0026#34;hybrid engine\u0026#34; class ElectricEngine(Engine): def description(self): return \u0026#34;electric engine\u0026#34; class GasolineEngine(Engine): def description(self): return \u0026#34;gasoline engine\u0026#34; Implementing concrete classes for Car with different engines:\nclass HybridCar(Car): def __init__(self, engine: Engine): self.engine = engine def assemble(self): return f\u0026#34;Assembling a car with a {self.engine.description()}\u0026#34; class ElectricCar(Car): def __init__(self, engine: Engine): self.engine = engine def assemble(self): return f\u0026#34;Assembling a car with a {self.engine.description()}\u0026#34; class GasolineCar(Car): def __init__(self, engine: Engine): self.engine = engine def assemble(self): return f\u0026#34;Assembling a car with a {self.engine.description()}\u0026#34; Abstract Factory for creating cars:\nclass CarFactory(ABC): @abstractmethod def create_car(self) -\u0026gt; Car: pass Concrete factory classes for Hybrid, Electric, and Gasoline cars:\nclass HybridCarFactory(CarFactory): def create_car(self) -\u0026gt; Car: return HybridCar(HybridEngine()) class ElectricCarFactory(CarFactory): def create_car(self) -\u0026gt; Car: return ElectricCar(ElectricEngine()) class GasolineCarFactory(CarFactory): def create_car(self) -\u0026gt; Car: return GasolineCar(GasolineEngine()) putting everything together:\ndef client_code(car_factory: CarFactory): car = car_factory.create_car() print(car.assemble()) hybrid_factory = HybridCarFactory() electric_factory = ElectricCarFactory() gasoline_factory = GasolineCarFactory() client_code(hybrid_factory) # Output: Assembling a car with a hybrid engine client_code(electric_factory) # Output: Assembling a car with a electric engine client_code(gasoline_factory) # Output: Assembling a car with a gasoline engine The Abstract Factory pattern allows us to create cars with different engines without specifying their concrete classes, making it easy to add new types of engines or cars in the future.\nNow, let\u0026rsquo;s understand the difference between Abstract Factory and Factory Method.\nAbstract Factory: It\u0026rsquo;s about creating families of related objects. Abstract Factory contains multiple Factory Methods for creating different types of products. Clients use the factory object to create objects of different types that belong to a specific family. Factory Method: It\u0026rsquo;s about creating one type of object. Factory Method defines a single method for object creation. Subclasses decide which class to instantiate. Clients use the Factory Method to create objects without knowing the actual class being instantiated. In summary, Abstract Factory is an extension of Factory Method that can create multiple related objects, while Factory Method focuses on creating a single type of object.\nHope the post have created some value. Peace!\n","permalink":"https://sukhdeepg.github.io/posts/abstract-factory/","summary":"Abstract Factory is a creational design pattern that helps create groups of related objects without knowing their specific classes. It\u0026rsquo;s particularly useful when we need to create objects that belong to a family, but we don\u0026rsquo;t care about the specific implementation.\nFirst, let\u0026rsquo;s understand create groups of related objects without knowing their specific classes with a small example:\nclass ShapeFactory: def create_shape(self, shape_type): if shape_type == \u0026#39;circle\u0026#39;: return Circle() elif shape_type == \u0026#39;square\u0026#39;: return Square() elif shape_type == \u0026#39;triangle\u0026#39;: return Triangle() factory = ShapeFactory() shape1 = factory.","title":"Abstract Factory with examples in Python"},{"content":"The Factory Method is a creational design pattern which is great for managing object creation in a clean, modular, and scalable way. It promotes loose coupling and code reusability. This pattern comes handy when we have multiple object types with a shared interface or base class, and we want to create new objects based on a given parameter without hardcoding the exact classes.\nWhat exactly does factory mean? \u0026ldquo;Factory\u0026rdquo; refers to an object that is responsible for creating another object. In real world factories, we input raw materials and design specfication and we get goods as an output. Here, we input a type or a set of parameters and we get an object as an output. Let\u0026rsquo;s understand the above with an example:\nfrom abc import ABC from abc import abstractmethod class Car(ABC): @abstractmethod def start(self): pass class ElectricCar(Car): def start(self): return \u0026#34;Starting electric car!\u0026#34; class GasolineCar(Car): def start(self): return \u0026#34;Starting gasoline car!\u0026#34; class HybridCar(Car): def start(self): return \u0026#34;Starting hybrid car!\u0026#34; Here, the ElectricCar, GasolineCar, and HybridCar, extends the Car abstract base class. This means the start method needs to be implemented. Now, we\u0026rsquo;ll create Car Factory.\nclass CarFactory: def __init__(self): self._car_map = {} def create_car(self, car_type): car_class = self._car_map.get(car_type) if car_class: return car_class() else: raise ValueError(f\u0026#34;Invalid car type: {car_type}\u0026#34;) def register_car(self, car_type, car_class): self._car_map[car_type] = car_class Now, we can create car objects based on the car_type parameter without hardcoding the exact classes. def main(): car_factory = CarFactory() car_factory.register_car(\u0026#34;electric\u0026#34;, ElectricCar) car_factory.register_car(\u0026#34;gasoline\u0026#34;, GasolineCar) car_factory.register_car(\u0026#34;hybrid\u0026#34;, HybridCar) electric_car = car_factory.create_car(\u0026#34;electric\u0026#34;) print(electric_car.start()) gasoline_car = car_factory.create_car(\u0026#34;gasoline\u0026#34;) print(gasoline_car.start()) hybrid_car = car_factory.create_car(\u0026#34;hybrid\u0026#34;) print(hybrid_car.start()) if __name__ == \u0026#34;__main__\u0026#34;: main() The output:\nStarting electric car! Starting gasoline car! Starting hybrid car! Now, the above has few benefits:\nDecoupling: CarFactory decouples the creation of car objects from their usage. Client doesn\u0026rsquo;t need to know about the concrete car classes (ElectricCar, GasolineCar, and HybridCar). This helps make code more modular and easy to maintain. Extensibility: If we need to add a new car type, we can simply create a new class for the car type, extend Car abstract base class, and register the car type with CarFactory. This helps adding new car types without affecting the existing code. Hope the post have created some value. Peace!\n","permalink":"https://sukhdeepg.github.io/posts/factory-method/","summary":"The Factory Method is a creational design pattern which is great for managing object creation in a clean, modular, and scalable way. It promotes loose coupling and code reusability. This pattern comes handy when we have multiple object types with a shared interface or base class, and we want to create new objects based on a given parameter without hardcoding the exact classes.\nWhat exactly does factory mean? \u0026ldquo;Factory\u0026rdquo; refers to an object that is responsible for creating another object.","title":"Factory Method with examples in Python"},{"content":"When we start our programming journey, with continuous practice and learning, writing code becomes easier. But, as we advance in our careers, it becomes equally important to learn how to maintain and help others maintain what we are writing. 1. Single Responsibility Principle Easy to understand. Every module, class, or function should only have a single responsibility or only one reason to change. But it’s difficult to practically implement because lines can get blurry during implementation.\nTo simplify this, Uncle Bob says that \u0026ldquo;This principle is about people\u0026rdquo; in this blog.\nLet’s understand with an example\nclass Payment: # process the payment def process(self): pass # save the payment def save(self): pass # retrieve the payment information def retrieve(self): pass # return analytics data related to payment. E.g. processing time of payment def analytics(self): pass # check if the information for payment is correct or not. E.g. card number, CVV, etc def check(self): pass As we can see, this class is performing a lot of functions for a given payment and has more than one reason to change. What if we have different people using these functionalities? If one person thinks to change the check function logic and return field to bool mapping dict e.g {“is_cvv_valid”: True} instead of list of field and bool tuple e.g. [(\u0026quot;is_cvv_valid\u0026quot;, True)], this will affect the processing logic and eventually, analytics will create panic!\nIt will be better if each functionality is isolated and handled by a single team or individual in order to avoid any dependency and compatibility issues. Each functionality will have a standard output format. So, even if the internal logic changes for a functionality, it won’t affect the other dependent functionalities and will also have a single responsibility and reason to change. This will make the code more cohesive and easier to maintain.\nclass ProcessPayment: def process(self): pass class SavePayment: def save(self): pass class RetrievePayment: def retrieve(self): pass class AnalyticsPayment: def analytics(self): pass class SecCheckPayment: def security_check(self): pass 2. Open-closed Principle Open for extension but closed for modification. Extension means that we’re extending the functionality of our code. Modification means that we’re modifying our existing code.\nNow, which sounds more risky? modification, right? Because when we write our code, test it, and deploy it, we should not go back and modify it, as this can lead to instability, create bugs, etc.\nIn Python (and in many other languages), we can make use of an abstract base class to help us extend the functionality of our code.\nLet’s understand with an example\nfrom abc import ABC, abstractmethod class Hardware(ABC): @abstractmethod def functionality(): pass class Monitor(Hardware): def functionality(self): print(\u0026#39;To display information on the screen.\u0026#39;) class Mouse(Hardware): def functionality(self): print(\u0026#39;To move cursor on the screen and click on elements.\u0026#39;) class Keyboard(Hardware): def functionality(self): print(\u0026#39;To help type the required information.\u0026#39;) mon = Monitor() mou = Mouse() key = Keyboard() mon.functionality() mou.functionality() key.functionality() Here, if we need to add functionality for Printer, we don’t need to modify any existing class or function, we can simply extend the Hardware class and create the functionality.\nclass Printer(Hardware): def functionality(self): print(\u0026#39;To print information on the paper.\u0026#39;) 3. Liskov Substitution Principle If we have an object of superclass (A) and an object of child class (B), then we should be able to replace A with B without affecting the existing behaviour of the program.\nContinuing the example from the Open-closed principle, if we want to create a function that takes the Hardware and prints its functionality, we don’t want to create if elif else condition blocks to decide what to print. Instead, it will be much cleaner to create a generic function that just takes an object and prints the functionality.\nfrom abc import ABC, abstractmethod class Hardware(ABC): @abstractmethod def functionality(): pass class Monitor(Hardware): def functionality(self): print(\u0026#39;To display information on the screen.\u0026#39;) class Mouse(Hardware): def functionality(self): print(\u0026#39;To move cursor on the screen and click on elements.\u0026#39;) class Keyboard(Hardware): def functionality(self): print(\u0026#39;To help type the required information.\u0026#39;) class Printer(Hardware): def functionality(self): print(\u0026#39;To print information on the paper.\u0026#39;) def print_functionality(h: Hardware): h.functionality() mon = Monitor() mou = Mouse() key = Keyboard() pri = Printer() print_functionality(mon) print_functionality(mou) print_functionality(key) print_functionality(pri) In the print_functionality function, we can easily replace the object of the Hardware class with objects of the Monitor, Mouse, Keyboard, Printer classes. 4. Interface Segregation Principle The interface segregation principle (ISP) states that no code should be forced to depend on methods it does not use. Source.\nIf we add the firmware_update function to our Hardware class, it would mean that, all our child classes would need to have the firmware_update function.\nclass Hardware(ABC): @abstractmethod def functionality(): pass @abstractmethod def firmware_update(): pass Now, this firmware_update function will not be used by the mouse and keyboard usually. So, why do these classes even need to have this function? This violates the ISP. To avoid this, we can have the following update\nfrom abc import ABC, abstractmethod class Hardware(ABC): @abstractmethod def functionality(): pass class Firmware(ABC): @abstractmethod def update(): pass class Monitor(Hardware, Firmware): def functionality(self): print(\u0026#39;To display information on the screen.\u0026#39;) def update(): print(\u0026#39;Updating firmware.\u0026#39;) class Mouse(Hardware): def functionality(self): print(\u0026#39;To move cursor on the screen and click on elements.\u0026#39;) class Keyboard(Hardware): def functionality(self): print(\u0026#39;To help type the required information.\u0026#39;) class Printer(Hardware, Firmware): def functionality(self): print(\u0026#39;To print information on the paper.\u0026#39;) def update(self): print(\u0026#39;Updating firmware.\u0026#39;) 5. Dependency Inversion Principle High-level modules or classes should not depend on low-level modules (concrete implementations) or classes. High-modules should depend on abstractions or interfaces.\nLet’s see example for high-level and low-level class\nfrom abc import ABC, abstractmethod class MusicPlayer: def play(self): music_service_a = MusicServiceA() music_service_a.play() class MusicServiceA: def play(self): print(\u0026#39;Playing music from MusicServiceA.\u0026#39;) mp = MusicPlayer() mp.play() MusicPlayer is the high-level class and MusicServiceA is the low-level class. Here, MusicPlayer is directly dependent on the MusicServiceA class. If tomorrow, we need another service to play music from, we would need to modify the MusicPlayer class which violates the OCP. To avoid this dependency, we can create a MusicService abstract class and pass it to the MusicPlayer.\nfrom abc import ABC, abstractmethod class MusicPlayer: def __init__(self, music_service): self.music_service = music_service def play(self): self.music_service.play() class MusicService(ABC): @abstractmethod def play(self): pass class MusicServiceA(MusicService): def play(self): print(\u0026#39;Playing music from MusicServiceA.\u0026#39;) class MusicServiceB(MusicService): def play(self): print(\u0026#39;Playing music from MusicServiceB.\u0026#39;) msa = MusicServiceA() msb = MusicServiceB() mp1 = MusicPlayer(msa) mp2 = MusicPlayer(msb) mp1.play() mp2.play() Conclusion We covered all the SOLID principles with Python examples (dos and don\u0026rsquo;ts) and simplified the definitions associated with the principles.\nHope the post have created some value. Peace!\n","permalink":"https://sukhdeepg.github.io/posts/solid/","summary":"When we start our programming journey, with continuous practice and learning, writing code becomes easier. But, as we advance in our careers, it becomes equally important to learn how to maintain and help others maintain what we are writing. 1. Single Responsibility Principle Easy to understand. Every module, class, or function should only have a single responsibility or only one reason to change. But it’s difficult to practically implement because lines can get blurry during implementation.","title":"SOLID Principles with examples in Python"}]