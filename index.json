[{"content":" Musings on building a Generative AI product The team aimed to improve job search and content on user\u0026rsquo;s feed by using generative AI. Allow faster access to information, connecting relevant content, offering advice, and more personalized experiences. Development Process: Overall Design: Implementation of Retrieval Augmented Generation (RAG) pipeline for efficient handling of user queries. Routing (Valid query check and selecting AI agent), retrieval (selecting which services to use), generation (generating the final response). Development Speed: Split tasks into independent agents for faster development across teams. Evaluation: Faced challenges in evaluating answer quality, tackled through guidelines, scaling annotation, and automatic evaluation. Calling Internal APIs: Internal APIs are called, and their responses are injected into a subsequent LLM prompt to provide additional context to ground the response. Consistent Quality: The team initially achieved 80% of their targeted experience within a month using generative AI, but faced challenges in detecting and mitigating errors, leading to a slower rate of improvement and a shift towards more prompt engineering to fine-tune large language models for a more data-driven pipeline. Capacity \u0026amp; Latency: Balanced quality, throughput, and member latency while managing GPU cluster costs and optimizing response times. Ongoing Work: Refining LLM training for a more data-driven approach. Enhancing deployment infrastructure for better predictability and efficiency. Reducing latency and wasted tokens in the pipeline. Building Meta’s GenAI Infrastructure Shepherd: How Stripe adapted Chronon to scale ML feature development How Stripe’s document databases supported 99.999% uptime with zero-downtime data migrations How data is powering skills-based hiring on LinkedIn Developing Rapidly With Generative AI This blog shares a structured approach to utilizing generative AI effectively. Stages: Ideation, defining requirements, prototyping, learning, and deploying at scale. Iterative Process: Continuous feedback loops during prototyping and learning. Considering latency, task complexity, prompt length, quality, safety, language support, and throughput. Balancing model size and response time against quality and cost. Using advanced commercial LLMs (e.g. ChatGPT) for initial validation and feedback. Reason being if state of the art LLMs cannot justify the use case being solved, then the direction needs to be checked. Architecture: Includes API gateway, LLM inference server, and content safety measures. Balancing cost, privacy, and performance between commercial and self-hosted models. Open-source models offer quality but may need fine-tuning and robust infrastructure. How We Built Slack AI To Be Secure and Private Video annotator: a framework for efficiently building video classifiers using vision-language models and active learning How Meta built Threads in 5 months Upgrading Uber’s MySQL Fleet to version 8.0 DoorDash Empowers Engineers with Kafka Self-Serve ","permalink":"https://sukhdeepg.github.io/engineering-blogs/engineering-blogs-list/","summary":"Musings on building a Generative AI product The team aimed to improve job search and content on user\u0026rsquo;s feed by using generative AI. Allow faster access to information, connecting relevant content, offering advice, and more personalized experiences. Development Process: Overall Design: Implementation of Retrieval Augmented Generation (RAG) pipeline for efficient handling of user queries. Routing (Valid query check and selecting AI agent), retrieval (selecting which services to use), generation (generating the final response).","title":"Engineering blogs list"},{"content":" Assisting in Writing Wikipedia-like Articles From Scratch with Large Language Models Graph Machine Learning in the Era of Large Language Models (LLMs) ","permalink":"https://sukhdeepg.github.io/annotated-research-papers/annotated-research-papers-list/","summary":" Assisting in Writing Wikipedia-like Articles From Scratch with Large Language Models Graph Machine Learning in the Era of Large Language Models (LLMs) ","title":"Annotated research papers list"},{"content":"The Visitor design pattern is like a tool that lets us add new features to our code without changing the original code. Imagine we have a bunch of different types of files on our computer (like documents, music, and videos), and we want to perform various tasks on them, like opening or scanning for viruses. Instead of adding new code to each file type, we create a \u0026ldquo;visitor\u0026rdquo; – a separate set of instructions or tool – that can interact with each type of file to perform the task. This way, our original files remain unchanged, and we can easily add new actions without messing with the existing setup.\nIn backend engineering, think of it as if we have different types of data (like user data, product data, etc.) stored in our system. We might need to perform tasks like validating or formatting this data differently. Instead of changing the original data structures, we create a \u0026ldquo;visitor\u0026rdquo; (a piece of code) that goes through each data type and performs the needed task. This makes our system more flexible and easier to update or maintain, as we can add new operations without altering the core structures of our data.\nImagine a tax inspector visiting different types of stores in a mall to assess taxes. Each store (like a bookstore, a restaurant, or a jewelry shop) handles the tax inspection differently due to their different types of business. However, the tax inspector (the \u0026ldquo;visitor\u0026rdquo;) can visit each store and apply the necessary tax rules without the stores needing to know the details of tax assessment processes. Each store just needs to allow the inspector to visit.\nLet\u0026rsquo;s understand this further with an example in Python:\nclass CarElement: def accept(self, visitor): pass class Body(CarElement): def accept(self, visitor): visitor.visitBody(self) class Engine(CarElement): def accept(self, visitor): visitor.visitEngine(self) class Car(CarElement): def __init__(self): self.elements = [Engine(), Body()] def accept(self, visitor): for element in self.elements: element.accept(visitor) visitor.visitCar(self) class CarElementVisitor: def visitBody(self, body): print(\u0026#34;Checking car body.\u0026#34;) def visitEngine(self, engine): print(\u0026#34;Checking engine.\u0026#34;) def visitCar(self, car): print(\u0026#34;Inspecting overall car.\u0026#34;) visitor = CarElementVisitor() car = Car() car.accept(visitor) Output:\nChecking engine. Checking car body. Inspecting overall car. Here we have different parts of a car (such as the Body and Engine) represented as classes, each inheriting from a common interface, CarElement. This setup allows various car parts to be treated uniformly. Each part class has an accept method that accepts a visitor object and calls a visit method on it, passing itself as an argument. This is how the car parts \u0026ldquo;accept\u0026rdquo; the visitor, allowing the visitor to perform specific actions on them.\nThe CarElementVisitor class is the visitor, equipped with different methods (visitBody, visitEngine, visitCar) to handle different types of car elements. These methods define what to do when visiting each type of part, like checking the car\u0026rsquo;s body or engine. A Car class represents the entire car and contains a collection of car parts. It also has an accept method, which lets the visitor visit each part of the car. In the end, when we create a Car object and a CarElementVisitor object, and let the car accept the visitor, it results in the visitor traversing and performing operations on each part of the car, demonstrating how we can perform various actions on the car\u0026rsquo;s components without changing the car\u0026rsquo;s design or structure. This makes it easy to add new features without altering existing code.\nThe Visitor pattern is often used in compilers for programming languages. In this context, the compiler uses the visitor to traverse an abstract syntax tree (AST) representing the source code. Each node in the tree may represent a different structure (e.g., expressions, statements, function calls). The visitor pattern allows the compiler to perform operations such as type checking, code optimization (constant folding or dead code elimination), or code generation on these nodes without changing the classes of the elements of the tree.\n","permalink":"https://sukhdeepg.github.io/design-patterns/visitor/","summary":"The Visitor design pattern is like a tool that lets us add new features to our code without changing the original code. Imagine we have a bunch of different types of files on our computer (like documents, music, and videos), and we want to perform various tasks on them, like opening or scanning for viruses. Instead of adding new code to each file type, we create a \u0026ldquo;visitor\u0026rdquo; – a separate set of instructions or tool – that can interact with each type of file to perform the task.","title":"Visitor with examples in Python"},{"content":"The Template Method design pattern is a behavioral design pattern that defines the program skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure. In simpler terms, it’s like a recipe with certain steps defined and fixed and allows the child classes to implement the specifics of these steps.\nImagine the process of making a sandwich. The steps might include gathering ingredients, putting ingredients between bread, and serving the sandwich. These steps form the \u0026ldquo;template\u0026rdquo; for making a sandwich. However, the specific ingredients (like vegetarian or non vegetarian options) can vary. Each type of sandwich will follow the same basic steps, but the specifics can be customized.\nLet\u0026rsquo;s understand this with an example in Python:\nfrom abc import ABC, abstractmethod class Car(ABC): # Template method def start_drive_stop(self): self.start() self.drive() self.stop() @abstractmethod def start(self): pass @abstractmethod def drive(self): pass @abstractmethod def stop(self): pass class SportsCar(Car): def start(self): print(\u0026#34;Sports car starting with roar\u0026#34;) def drive(self): print(\u0026#34;Sports car driving fast\u0026#34;) def stop(self): print(\u0026#34;Sports car stopping\u0026#34;) class FamilyCar(Car): def start(self): print(\u0026#34;Family car starting quietly\u0026#34;) def drive(self): print(\u0026#34;Family car driving safely\u0026#34;) def stop(self): print(\u0026#34;Family car stopping smoothly\u0026#34;) sports_car = SportsCar() sports_car.start_drive_stop() family_car = FamilyCar() family_car.start_drive_stop() Output:\nSports car starting with roar Sports car driving fast Sports car stopping Family car starting quietly Family car driving safely Family car stopping smoothly The Template Method pattern is often used in frameworks. For example, in web application frameworks, there are common steps to handle HTTP requests, such as authentication, loading data, rendering views, and sending responses. The framework defines the order of these steps, but allows developers to customize the behavior of each step.\nAlso frequently used in data processing applications, where the skeleton of the processing algorithm is defined (e.g., reading data, processing data, and writing results), but the actual processing logic varies depending on the type of data or the specific requirements of the processing task.\n","permalink":"https://sukhdeepg.github.io/design-patterns/template-method/","summary":"The Template Method design pattern is a behavioral design pattern that defines the program skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure. In simpler terms, it’s like a recipe with certain steps defined and fixed and allows the child classes to implement the specifics of these steps.\nImagine the process of making a sandwich. The steps might include gathering ingredients, putting ingredients between bread, and serving the sandwich.","title":"Template Method with examples in Python"},{"content":"The Strategy design pattern lets us change the way an object behaves while the program is running. Imagine having a video game character that can switch tools like a hammer, a sword, or a shield based on what we choose during the game. Similarly, by using the Strategy pattern, we can change how an object acts on the fly, without stopping or changing the rest of our program.\nConsider a navigation app that suggests routes to the destination. The app can change the strategy based on the preference of the user: fastest route, shortest route, or least traffic. These strategies can be switched easily without altering the user\u0026rsquo;s interaction with the app.\nLet\u0026rsquo;s understand the above with a Python example:\nclass BrakeBehavior: def apply_brake(self): pass class NormalBrake(BrakeBehavior): def apply_brake(self): return \u0026#34;Normal braking applied\u0026#34; class ABSBrake(BrakeBehavior): def apply_brake(self): return \u0026#34;ABS braking applied\u0026#34; class Car: def __init__(self, brake_behavior: BrakeBehavior): self.brake_behavior = brake_behavior def apply_brake(self): return self.brake_behavior.apply_brake() # Method to change the brake behavior at runtime def set_brake_behavior(self, new_brake_behavior: BrakeBehavior): self.brake_behavior = new_brake_behavior car = Car(NormalBrake()) print(car.apply_brake()) # Change the behavior at runtime car.set_brake_behavior(ABSBrake()) print(car.apply_brake()) Output:\nNormal braking applied ABS braking applied the Car object starts with a normal braking behavior. Then, while the program is still running, we change the car\u0026rsquo;s braking behavior to ABS braking by using the set_brake_behavior method. This demonstrates changing the object\u0026rsquo;s behavior at runtime, which is the core concept of the Strategy design pattern.\nThe Strategy pattern is widely used in software engineering for features like compression, where different algorithms can be applied based on user choice or data type (e.g., ZIP, RAR). It\u0026rsquo;s also common in payment processing systems, where different payment strategies can be applied depending on the payment method chosen by the user (e.g., credit card, PayPal, cryptocurrency).\nSorting algorithms in database systems or frameworks. Depending on the amount of data and its type, different sorting strategies can be applied (e.g., quick sort, merge sort, bubble sort) to optimize performance and resource usage without changing the code that uses the sorting functionality.\n","permalink":"https://sukhdeepg.github.io/design-patterns/strategy/","summary":"The Strategy design pattern lets us change the way an object behaves while the program is running. Imagine having a video game character that can switch tools like a hammer, a sword, or a shield based on what we choose during the game. Similarly, by using the Strategy pattern, we can change how an object acts on the fly, without stopping or changing the rest of our program.\nConsider a navigation app that suggests routes to the destination.","title":"Strategy with examples in Python"},{"content":"This one can be bit tricky to understand first, but please read through the complete post, you\u0026rsquo;ll get it.\nThe State design pattern is a method used in programming to allow an object to behave differently depending on its internal condition (refers to the current situation or status of an object, determined by its properties or attributes.) or \u0026ldquo;state\u0026rdquo;. This pattern involves creating different \u0026ldquo;state\u0026rdquo; objects for each possible condition, and a main object, called the \u0026ldquo;context\u0026rdquo;, which changes its behavior based on whichever state object is currently active. Instead of the context object needing to keep track of its state using conditions or flags, it simply delegates behavior to its current state object. This makes the code cleaner and easier to understand, as each state can be managed independently, and the main object doesn\u0026rsquo;t need complex logic to handle its different behaviors.\nThink of a vending machine that operates differently based on its current state: if the machine is in a \u0026ldquo;ready\u0026rdquo; state, it waits for customer input; if it\u0026rsquo;s in a \u0026ldquo;selection made\u0026rdquo; state, it asks for money; and if it\u0026rsquo;s in a \u0026ldquo;dispensing\u0026rdquo; state, it provides the product and returns to the \u0026ldquo;ready\u0026rdquo; state. The vending machine behaves differently depending on its internal state, but the way we interact with it remains consistent.\nLet\u0026rsquo;s understand further with Python example:\nHere, the Car class that can be in different states like Parked, Driving, or Stopped. Depending on the state, the drive and stop methods of the Car class behave differently. Each state is represented by a separate class that implements the same interface, and the Car class changes its behavior by switching between these state instances.\nclass State: def handle_drive(self): pass def handle_stop(self): pass class ParkedState(State): def handle_drive(self): print(\u0026#34;Switching to Driving state\u0026#34;) return DrivingState() def handle_stop(self): print(\u0026#34;Already parked\u0026#34;) return self class DrivingState(State): def handle_drive(self): print(\u0026#34;Already driving\u0026#34;) return self def handle_stop(self): print(\u0026#34;Switching to Parked state\u0026#34;) return ParkedState() class Car: def __init__(self): self.state = ParkedState() def drive(self): self.state = self.state.handle_drive() def stop(self): self.state = self.state.handle_stop() car = Car() car.drive() car.stop() Output:\nSwitching to Driving state Switching to Parked state In backend engineering, a common real-world example of the State design pattern is in the management of a user\u0026rsquo;s session on a website. A user session can have various states such as \u0026ldquo;Logged Out\u0026rdquo;, \u0026ldquo;Logged In\u0026rdquo;, \u0026ldquo;Idle\u0026rdquo;, or \u0026ldquo;Expired\u0026rdquo;. The session object (context) behaves differently depending on its current state: when \u0026ldquo;Logged Out\u0026rdquo;, it might only allow access to public pages; when \u0026ldquo;Logged In\u0026rdquo;, it grants access to protected resources; when \u0026ldquo;Idle\u0026rdquo;, it might send reminders or prompts to the user; and when \u0026ldquo;Expired\u0026rdquo;, it requires the user to log in again.\nEach of these states is represented by a separate state object that knows how to handle requests in that specific state. The session context delegates requests to its current state object, which handles the request based on the rules for that state. This modularizes the code and makes it clearer and easier to manage, as each state\u0026rsquo;s behavior is encapsulated in its own class.\n","permalink":"https://sukhdeepg.github.io/design-patterns/state/","summary":"This one can be bit tricky to understand first, but please read through the complete post, you\u0026rsquo;ll get it.\nThe State design pattern is a method used in programming to allow an object to behave differently depending on its internal condition (refers to the current situation or status of an object, determined by its properties or attributes.) or \u0026ldquo;state\u0026rdquo;. This pattern involves creating different \u0026ldquo;state\u0026rdquo; objects for each possible condition, and a main object, called the \u0026ldquo;context\u0026rdquo;, which changes its behavior based on whichever state object is currently active.","title":"State with examples in Python"},{"content":"The Observer design pattern is a behavioral design pattern where an object, known as the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes, usually by calling one of their methods. It\u0026rsquo;s commonly used to implement distributed event handling systems.\nA real-world analogy for the Observer pattern is a subscription to a newspaper or magazine. In this analogy, the newspaper is the subject, and the subscribers are the observers. Whenever there is a new edition of the newspaper, all subscribers automatically receive it. If a subscriber decides to cancel their subscription, they stop receiving new editions.\nLet\u0026rsquo;s see an example in Python:\nA car tracking system where the car\u0026rsquo;s speed and fuel level are monitored. We\u0026rsquo;ll have a Car class as the subject, and two observer classes: SpeedAlert and FuelAlert. The SpeedAlert observer will be notified when the car exceeds a certain speed limit, while FuelAlert will be notified when the fuel level drops below a certain threshold.\nclass Car: # Subject def __init__(self): self._speed = 0 self._fuel_level = 100 self._observers = [] def attach(self, observer): self._observers.append(observer) def detach(self, observer): self._observers.remove(observer) def notify(self): for observer in self._observers: observer.update(self) def set_speed(self, speed): self._speed = speed self.notify() def set_fuel_level(self, level): self._fuel_level = level self.notify() @property def speed(self): return self._speed @property def fuel_level(self): return self._fuel_level class SpeedAlert: # Observer for speed def update(self, car): if car.speed \u0026gt; 100: # Assuming 100 is the speed limit print(f\u0026#34;Speed Alert: Your speed is {car.speed} km/h, which exceeds the safe speed limit!\u0026#34;) class FuelAlert: # Observer for fuel def update(self, car): if car.fuel_level \u0026lt; 20: # Assuming 20 is the low fuel threshold print(f\u0026#34;Fuel Alert: You are running low on fuel. Only {car.fuel_level}% remaining!\u0026#34;) car = Car() speed_alert = SpeedAlert() fuel_alert = FuelAlert() car.attach(speed_alert) car.attach(fuel_alert) car.set_speed(120) # triggers SpeedAlert car.set_fuel_level(15) # triggers FuelAlert Output:\nSpeed Alert: Your speed is 120 km/h, which exceeds the safe speed limit! Speed Alert: Your speed is 120 km/h, which exceeds the safe speed limit! Fuel Alert: You are running low on fuel. Only 15% remaining! In software engineering, the Observer pattern is most frequently used in event management systems, such as GUI toolkits. For example, in a web application, this pattern is used to listen to user events like clicks or mouse movements and update the view accordingly without the user having to manually refresh the page.\nAnother common real-world application of the Observer pattern is in the implementation of Model-View-Controller (MVC) architecture, particularly for web applications. In MVC, the Model acts as the subject, while Views act as observers. When the Model changes (for instance, a database update), it notifies the Views, leading to an automatic update of the user interface.\n","permalink":"https://sukhdeepg.github.io/design-patterns/observer/","summary":"The Observer design pattern is a behavioral design pattern where an object, known as the subject, maintains a list of its dependents, called observers, and notifies them automatically of any state changes, usually by calling one of their methods. It\u0026rsquo;s commonly used to implement distributed event handling systems.\nA real-world analogy for the Observer pattern is a subscription to a newspaper or magazine. In this analogy, the newspaper is the subject, and the subscribers are the observers.","title":"Observer with examples in Python"},{"content":"The Memento design pattern is like a save point for an object\u0026rsquo;s information, allowing that object to be returned to its previous state later on. This is similar to saving a game and then loading it back up; we get everything back as it was, without needing to know how the game internally manages all its details. This approach is very useful in making features like the \u0026lsquo;undo\u0026rsquo; option in many software applications, as it helps reverse actions without disrupting the private workings of the objects involved.\nImagine we are writing a document using a text editor, and we can press \u0026ldquo;Ctrl + Z\u0026rdquo; to undo our last action. In this scenario, each state of the document before a change is made acts as a \u0026ldquo;memento.\u0026rdquo; The text editor saves these states without exposing the details of the content (encapsulation). The encapsulation here means that the text editor keeps a record of its changes in a way that the inner workings are not shown or affected – this is similar to keeping personal notes private while still being able to refer back to them when needed. When we press undo, the editor restores the document to the last saved state.\nLet\u0026rsquo;s see an example in Python for this:\nclass CarMemento: def __init__(self, state): self._state = state def get_state(self): return self._state class Car: def __init__(self): self._state = \u0026#34;\u0026#34; def set_state(self, state): self._state = state def save_state_to_memento(self): return CarMemento(self._state) def get_state_from_memento(self, memento): self._state = memento.get_state() car = Car() car.set_state(\u0026#34;Engine on\u0026#34;) saved_states = [] saved_states.append(car.save_state_to_memento()) car.set_state(\u0026#34;Engine off\u0026#34;) car.get_state_from_memento(saved_states[0]) # Restores to \u0026#34;Engine on\u0026#34; print(f\u0026#34;current state: {car._state}\u0026#34;) Output:\ncurrent state: Engine on In software engineering, the Memento pattern is commonly used in the implementation of undo mechanisms in applications like text editors, graphic editors, and browsers. It allows these applications to store snapshots of their current state at various points in time and restore them as needed without revealing the internals of their state.\nAnother frequent use case for the Memento pattern is in game development, where it can be used to save the state of a game, allowing players to save their progress and later reload it from exactly the same point. This includes saving the state of characters, levels, and items without exposing the complex internals of how these are maintained.\n","permalink":"https://sukhdeepg.github.io/design-patterns/memento/","summary":"The Memento design pattern is like a save point for an object\u0026rsquo;s information, allowing that object to be returned to its previous state later on. This is similar to saving a game and then loading it back up; we get everything back as it was, without needing to know how the game internally manages all its details. This approach is very useful in making features like the \u0026lsquo;undo\u0026rsquo; option in many software applications, as it helps reverse actions without disrupting the private workings of the objects involved.","title":"Memento with examples in Python"},{"content":"The mediator design pattern is a behavioral design pattern that allows us to reduce chaotic dependencies between objects. The pattern restricts direct communications between the objects and forces them to collaborate only via a mediator object. This helps to decrease the coupling between classes of objects and the complexity of their relationships.\nImagine a typical airport control tower. The pilots do not communicate directly with each other; instead, they speak to the control tower. The control tower (the mediator) then directs the planes (the objects) when to take off or land, ensuring that no two planes attempt to use the runway at the same time. In this analogy, the control tower is the mediator facilitating communication between planes.\nLet\u0026rsquo;s see an example in Python\nclass Mediator: def notify(self, sender, event): pass class Car(Mediator): def __init__(self): self.components = [] def add_component(self, component): self.components.append(component) def notify(self, sender, event): for component in self.components: if component is not sender: component.receive(event) class Engine: def __init__(self, mediator): self.mediator = mediator def start(self): print(\u0026#34;Engine started\u0026#34;) self.mediator.notify(self, \u0026#34;ENGINE_STARTED\u0026#34;) def receive(self, event): if event == \u0026#34;FUEL_LOW\u0026#34;: print(\u0026#34;Engine: Received notice of low fuel\u0026#34;) class FuelGauge: def __init__(self, mediator): self.mediator = mediator def low_fuel(self): print(\u0026#34;Fuel Gauge: Fuel is low\u0026#34;) self.mediator.notify(self, \u0026#34;FUEL_LOW\u0026#34;) def receive(self, event): # FuelGauge might not need to react to other components\u0026#39; events pass mediator = Car() engine = Engine(mediator) fuel_gauge = FuelGauge(mediator) mediator.add_component(engine) mediator.add_component(fuel_gauge) fuel_gauge.low_fuel() # This will notify the engine about the low fuel engine.start() # This could notify other components that the engine has started Output:\nFuel Gauge: Fuel is low Engine: Received notice of low fuel Engine started In this example, Car acts as a mediator for the Engine and FuelGauge components. The components communicate with each other through the Car (mediator) instead of directly.\nCommon use case for the Mediator design pattern is in the implementation of event handling systems, particularly in web development frameworks like React or Angular. In these environments, the Mediator pattern can be employed to manage complex sets of interactions between various UI components. Instead of allowing each component to directly communicate with others, an event manager (the mediator) is used to handle events and coordinate the responses between components. This approach simplifies the communication logic, making the application easier to develop and maintain by centralizing the event handling logic, reducing direct dependencies among components, and improving the overall system modularity and reusability.\n","permalink":"https://sukhdeepg.github.io/design-patterns/mediator/","summary":"The mediator design pattern is a behavioral design pattern that allows us to reduce chaotic dependencies between objects. The pattern restricts direct communications between the objects and forces them to collaborate only via a mediator object. This helps to decrease the coupling between classes of objects and the complexity of their relationships.\nImagine a typical airport control tower. The pilots do not communicate directly with each other; instead, they speak to the control tower.","title":"Mediator with examples in Python"},{"content":"The Iterator design pattern provides a standard way to loop through a collection of objects without exposing the underlying representation (array, list, map, etc.). It allows us to access elements sequentially without needing to understand the inner workings of the collection.\nImagine we\u0026rsquo;re at a pancake house with a menu of different pancake types. We want to look through all the pancake types one by one to decide which one to order. The menu acts as an iterator in this scenario. We don\u0026rsquo;t need to know how the pancakes are stored in the kitchen or how the menu is organized; we just flip through the pages (or items), considering each option sequentially until we find what we like.\nclass CarCollection: def __init__(self): self._cars = [] def add_car(self, car): self._cars.append(car) def __iter__(self): return self.CarIterator(self._cars) class CarIterator: def __init__(self, cars): self._cars = cars self._index = 0 def __next__(self): try: car = self._cars[self._index] self._index += 1 return car except IndexError: raise StopIteration() # Usage: car_collection = CarCollection() car_collection.add_car(\u0026#39;Toyota\u0026#39;) car_collection.add_car(\u0026#39;Honda\u0026#39;) car_collection.add_car(\u0026#39;Ford\u0026#39;) for car in car_collection: print(car) Output:\nToyota Honda Ford In this example, CarCollection is a collection of cars, and CarIterator is an iterator for this collection. This setup lets us loop through all the cars in car_collection without knowing how they are stored internally.\nThe Iterator pattern is widely used in software development, particularly in the design of collections in programming languages and frameworks. For example:\nJava Collections Framework (JCF): The JCF uses the Iterator pattern extensively to allow users to traverse through sets, lists, and maps without knowing their internal representations.\nPython Collections: The Collections Module offers specialized container data types like Counter, Deque, and OrderedDict, complementing basic types such as lists and dictionaries. Python\u0026rsquo;s design inherently supports the Iterator pattern; built-in structures and those from the Collections Module are iterable, allowing seamless data traversal using the for loop or by creating iterators with iter(). For example, iterating over a list:\nmy_list = [1, 2, 3] for item in my_list: print(item) Here, Python uses the iterator protocol behind the scenes, similar to how one might iterate over collections in other languages.\nDatabase Query Results: When we execute a query that returns multiple records, the returned object (like a ResultSet in Java) often implements the Iterator pattern to let us go through each record one by one.\nFile Systems: When we need to list all files in a directory, the iterator pattern is used to go through each file without needing to know how the file list is implemented internally.\nThese examples demonstrate how the Iterator pattern facilitates the separation of concerns by hiding complex structures and providing a simple interface to traverse a collection of objects.\n","permalink":"https://sukhdeepg.github.io/design-patterns/iterator/","summary":"The Iterator design pattern provides a standard way to loop through a collection of objects without exposing the underlying representation (array, list, map, etc.). It allows us to access elements sequentially without needing to understand the inner workings of the collection.\nImagine we\u0026rsquo;re at a pancake house with a menu of different pancake types. We want to look through all the pancake types one by one to decide which one to order.","title":"Iterator with examples in Python"},{"content":"The Command design pattern is a way to organize actions in software so that the requests (like user commands or system operations) are turned into objects. This makes it easier to manage and modify these requests, like putting them in a queue or undoing them. It also helps in separating the part of the software that asks for something to be done from the part that actually does it.\nImagine a restaurant where customers (the client) give their orders (the command) to a waiter (the invoker) who then forwards the orders to the kitchen (the receiver) to prepare the meal. In this scenario, the order is an object which contains all the information needed to prepare the meal. The kitchen doesn\u0026rsquo;t need to know who the customer is; it just needs to know what to cook, which is what the order object encapsulates.\nHere is a simplified example in Python\nclass Car: def start(self): print(\u0026#34;Car has started.\u0026#34;) def stop(self): print(\u0026#34;Car has stopped.\u0026#34;) class Command: def execute(self): pass class StartCarCommand(Command): def __init__(self, car): self.car = car def execute(self): self.car.start() class StopCarCommand(Command): def __init__(self, car): self.car = car def execute(self): self.car.stop() # Client code car = Car() start_command = StartCarCommand(car) stop_command = StopCarCommand(car) # Invoker class CarRemote: def submit(self, command): command.execute() remote = CarRemote() remote.submit(start_command) remote.submit(stop_command) Output:\nCar has started. Car has stopped. In this code example, the Command pattern is used to control a car\u0026rsquo;s operations (starting and stopping) through command objects (StartCarCommand and StopCarCommand). Each command encapsulates an action and its recipient (the Car object). This setup allows for flexible command execution via the CarRemote (the invoker), which can call different commands without knowing the details of how these actions are carried out. This separation of concerns makes it easier to add new commands, change the car\u0026rsquo;s functionality, or extend the remote\u0026rsquo;s capabilities without altering the existing code structure, demonstrating the Command pattern\u0026rsquo;s usefulness in organizing and extending functionalities systematically.\nA common real-world use case for the Command design pattern is in implementing undo and redo functionalities in applications like text editors, graphic design tools, or any kind of software that manipulates data or documents. In such applications, each action performed by the user, such as typing text, changing color, moving objects, or resizing elements, is encapsulated in a command object with a specific execute method for performing the action and an undo method for reversing it.\nThis approach allows the software to maintain a history of actions executed by the user. When the user requests an undo, the software can simply call the undo method on the most recent command object to revert the last action. Similarly, redo operations can re-execute the command. This system makes it easy to add new types of actions, as each action is encapsulated in its own command class, without altering the core functionality of the application. It ensures high flexibility and scalability in managing user interactions and data manipulations.\n","permalink":"https://sukhdeepg.github.io/design-patterns/command/","summary":"The Command design pattern is a way to organize actions in software so that the requests (like user commands or system operations) are turned into objects. This makes it easier to manage and modify these requests, like putting them in a queue or undoing them. It also helps in separating the part of the software that asks for something to be done from the part that actually does it.\nImagine a restaurant where customers (the client) give their orders (the command) to a waiter (the invoker) who then forwards the orders to the kitchen (the receiver) to prepare the meal.","title":"Command with examples in Python"},{"content":"The Chain of Responsibility pattern is a design approach in programming that lets us pass requests through a series of processing units or \u0026ldquo;handlers\u0026rdquo;. Each handler is a piece of code or a function that has the chance to process the request, or pass it along to the next handler in the sequence. This method helps in organizing code in a way that separates the request sender from its processors, allowing for dynamic handling of requests based on runtime conditions. This pattern promotes the principle of loose coupling and is particularly useful when the exact handler is not known in advance.\nImagine a customer support system in a company. When a customer raises a complaint or query, it first reaches the front desk (the first level of support). If the front desk can\u0026rsquo;t solve the issue, the query is passed to the technical support team (the second level). If the technical team also can\u0026rsquo;t solve it, the query is finally escalated to the engineering team (the third level). Each level in this chain has the opportunity to resolve the issue or pass it along to the next level.\nLet\u0026rsquo;s illustrate the Chain of Responsibility pattern with a simple Python example that simulates a car service chain. In this example, each service station checks a particular aspect of the car (e.g., Oil Check, Air Filter Check, and Brake Check) and either handles the task or passes it to the next service station in the chain.\nclass Handler: \u0026#34;\u0026#34;\u0026#34;Abstract handler\u0026#34;\u0026#34;\u0026#34; def __init__(self, successor=None): self._successor = successor def handle_request(self, request): raise NotImplementedError(\u0026#39;Must provide implementation in subclass!\u0026#39;) class OilCheckHandler(Handler): def handle_request(self, request): if request == \u0026#34;Oil Check\u0026#34;: print(\u0026#34;Oil Check Done!\u0026#34;) elif self._successor is not None: self._successor.handle_request(request) class AirFilterCheckHandler(Handler): def handle_request(self, request): if request == \u0026#34;Air Filter Check\u0026#34;: print(\u0026#34;Air Filter Check Done!\u0026#34;) elif self._successor is not None: self._successor.handle_request(request) class BrakeCheckHandler(Handler): def handle_request(self, request): if request == \u0026#34;Brake Check\u0026#34;: print(\u0026#34;Brake Check Done!\u0026#34;) elif self._successor is not None: self._successor.handle_request(request) # Creating the chain chain = OilCheckHandler(AirFilterCheckHandler(BrakeCheckHandler())) # Sending requests chain.handle_request(\u0026#34;Oil Check\u0026#34;) chain.handle_request(\u0026#34;Air Filter Check\u0026#34;) chain.handle_request(\u0026#34;Brake Check\u0026#34;) Output:\nOil Check Done! Air Filter Check Done! Brake Check Done! This code simulates a scenario where a car goes through various service checks. Each handler in the chain has a specific task to perform and knows how to pass tasks it cannot handle to the next handler.\nA frequent real-world use case for the Chain of Responsibility pattern is in the processing of financial transactions, particularly in payment authorization systems. In such systems, a transaction request might need to pass through several checks or validations before it can be approved. These checks might include verifying the account balance, checking for fraud patterns, ensuring compliance with legal regulations, and finally, processing the payment itself.\nEach of these checks represents a handler in the chain. The transaction request is passed along this chain until it either gets approved (processed by a handler) or rejected (fails a check at some handler). This design allows for flexible addition or removal of checks without altering the core processing logic or affecting other checks, making the system highly adaptable to changing requirements or regulations.\n","permalink":"https://sukhdeepg.github.io/design-patterns/chain-of-responsibility/","summary":"The Chain of Responsibility pattern is a design approach in programming that lets us pass requests through a series of processing units or \u0026ldquo;handlers\u0026rdquo;. Each handler is a piece of code or a function that has the chance to process the request, or pass it along to the next handler in the sequence. This method helps in organizing code in a way that separates the request sender from its processors, allowing for dynamic handling of requests based on runtime conditions.","title":"Chain of Responsibility with examples in Python"},{"content":"The Proxy Design Pattern is like having a gatekeeper for an object, where the gatekeeper controls who can access the object and how they can use it. It\u0026rsquo;s like having a security guard for a building; the guard checks who the person is and decides if they can enter, and might also keep track of who comes in and out. This pattern lets us add a layer around an object that handles these checks and controls without changing the object itself. So, it\u0026rsquo;s a way to manage access and interactions with the object in a controlled manner.\nImagine we are trying to buy a ticket for a concert. Instead of buying the ticket directly from the concert hall, we go through a ticketing agent. This agent provides us with additional services such as finding the best seats, handling the payment process, and even giving us some advice on the event. Here, the ticketing agent acts as a proxy between us and the concert hall. The agent controls access to the concert hall\u0026rsquo;s tickets and adds some level of indirection, which can be beneficial for both us and the concert hall.\nIn this example, we have a Car class, and we want to control access to this class with a CarProxy class.\nclass Car: def drive(self): print(\u0026#34;Car has been driven\u0026#34;) class CarProxy: def __init__(self, driver_age): self.driver_age = driver_age self.real_car = Car() def drive(self): if self.driver_age \u0026gt;= 18: self.real_car.drive() else: print(\u0026#34;Sorry, the driver is too young to drive.\u0026#34;) # Usage young_driver = CarProxy(driver_age=16) young_driver.drive() adult_driver = CarProxy(driver_age=25) adult_driver.drive() In this example, the CarProxy controls access to the Car\u0026rsquo;s drive method based on the driver\u0026rsquo;s age, acting as a protective proxy.\nOutput:\nSorry, the driver is too young to drive. Car has been driven In software engineering, the Proxy Design Pattern is often applied to manage database connections efficiently, serving as a real-world example of its utility. A Database Connection Proxy acts as an intermediary between an application and its database, handling tasks like connection pooling to reduce the overhead of repeatedly opening and closing connections, caching frequent queries to improve performance, enforcing access control to enhance security, and logging queries for monitoring and analytics purposes. This approach is particularly beneficial in high-traffic scenarios, such as an e-commerce platform, where it ensures scalability, security, and performance by managing how the application interacts with the database, demonstrating the pattern\u0026rsquo;s capability to offer a flexible and effective solution for resource management. ProxySQL is a good example of this.\n","permalink":"https://sukhdeepg.github.io/design-patterns/proxy/","summary":"The Proxy Design Pattern is like having a gatekeeper for an object, where the gatekeeper controls who can access the object and how they can use it. It\u0026rsquo;s like having a security guard for a building; the guard checks who the person is and decides if they can enter, and might also keep track of who comes in and out. This pattern lets us add a layer around an object that handles these checks and controls without changing the object itself.","title":"Proxy with examples in Python"},{"content":"The flyweight design pattern is a way to save memory by sharing as much data as possible with similar objects. It\u0026rsquo;s like having a library where instead of buying a book every time we want to read it, we just borrow it, read it, and return it. This way, many people can read the book, but there\u0026rsquo;s only one copy that everyone shares.\nIn real world, imagine we have a company that creates business cards. Instead of printing a new card for each employee, we have a template that has the company\u0026rsquo;s logo, the font, and the design. When a new employee needs a card, we only change the name and contact details but use the same template for everything else. That template is like the shared part in the flyweight pattern.\nLet\u0026rsquo;s understand this with an example, say we have a program that manages a fleet of cars. Without the flyweight pattern, we might create a complete object for each car, which can take up a lot of memory if we have thousands of cars. But many cars share properties like model, brand, or color. With the flyweight pattern, we can create a class that only stores the shared data once and then create smaller, individual objects for each car that reference the shared data.\nclass CarModel: # The Flyweight Class def __init__(self, brand, model, color): self.brand = brand self.model = model self.color = color class Car: # The Context Class def __init__(self, vin, owner, car_model): self.vin = vin self.owner = owner self.car_model = car_model # Flyweight Factory class CarFactory: _models = {} def get_car_model(self, brand, model, color): # Returns an existing instance or creates a new one if it doesn\u0026#39;t exist if (brand, model, color) not in self._models: self._models[(brand, model, color)] = CarModel(brand, model, color) return self._models[(brand, model, color)] car_factory = CarFactory() # Let\u0026#39;s say we need to create two cars with the same model and color car1 = Car(\u0026#34;VIN12345\u0026#34;, \u0026#34;Alice\u0026#34;, car_factory.get_car_model(\u0026#34;Tesla\u0026#34;, \u0026#34;Model S\u0026#34;, \u0026#34;White\u0026#34;)) car2 = Car(\u0026#34;VIN67890\u0026#34;, \u0026#34;Bob\u0026#34;, car_factory.get_car_model(\u0026#34;Tesla\u0026#34;, \u0026#34;Model S\u0026#34;, \u0026#34;White\u0026#34;)) # Both car1 and car2 share the same CarModel instance. Practically in code, this pattern can be used in a video game (for this I\u0026rsquo;ve taken reference from refectoring.guru\u0026rsquo;s tree example and pseudocode), we might have thousands of trees in the background. Instead of creating a separate object in memory for each tree, which could be very memory-intensive, we use the flyweight pattern. We create a single tree object and then reference it every time we need a new tree in the game\u0026rsquo;s world. We only store the position of each tree uniquely. This saves memory and allows the game to run smoother on devices with less RAM.\nThis looks very similar to cache right? both aim to improve efficiency by reusing objects that are expensive to create. Here are few points around this:\nReuse of Instances: Just as a cache stores data so that future requests for that data can be served faster, the flyweight pattern keeps instances of similar objects that can be reused. This avoids the overhead of creating a new instance each time.\nMemory Savings: Both patterns help save memory. A cache does this by storing data that can be reused, thereby avoiding the need to recompute or reload data from a slower part of the system. Similarly, the flyweight pattern stores common data externally and shares it among objects, thus reducing the memory footprint.\nPerformance Improvement: The use of caches can greatly speed up access to data that would otherwise take a long time to retrieve or compute. Similarly, the flyweight pattern can speed up programs by avoiding the need to instantiate many similar objects, which can be computationally expensive.\nThe difference is mainly in their intent and use cases:\nA cache is a general-purpose storage mechanism that can hold any kind of data and is typically used to store results of operations, computations, or network calls. The flyweight pattern is a design pattern specifically used in object-oriented programming when creating a large number of similar objects. In essence, we could say that the flyweight pattern implements a form of caching for object instances. It\u0026rsquo;s a more specialized form of caching that is focused on sharing object state to minimize memory usage, rather than speeding up data retrieval.\nNow, let\u0026rsquo;s understand 2 important states of flyweight pattern. Intrinsic and Extrinsic. The intrinsic state refers to the information that is shared and does not vary between objects. This shared data is kept in the flyweight object and is independent of the flyweight\u0026rsquo;s context, meaning that it is common to all objects and doesn\u0026rsquo;t change from one object to another. The intrinsic state is what enables the memory efficiency of the flyweight pattern, as it is only stored once and referenced by all the individual objects that need it.\nOn the other hand, the extrinsic state consists of the information that varies between objects and is passed to the flyweight upon request. This state is context-specific and changes from one object to another. Since the extrinsic state is not shared, it must be stored externally and must be computed or applied each time it is used. In the flyweight pattern, this is the state that we would pass through method parameters when calling flyweight methods.\nExample explaining both these states: Here we have a class representing different types of trees in a forest. The type of tree (like \u0026lsquo;Oak\u0026rsquo;, \u0026lsquo;Maple\u0026rsquo;, etc.) represents the intrinsic state, which is shared among all trees of the same type. The position of each tree in the forest represents the extrinsic state, which is unique for each tree instance.\n# Flyweight class to store intrinsic state class TreeType: def __init__(self, name, color, texture): self.name = name # Intrinsic State self.color = color # Intrinsic State self.texture = texture # Intrinsic State def display(self, x, y): print(f\u0026#34;Displaying a {self.color} {self.name} tree at ({x}, {y}).\u0026#34;) # Factory to manage TreeType flyweight instances class TreeFactory: _tree_types = {} @classmethod def get_tree_type(cls, name, color, texture): if (name, color, texture) not in cls._tree_types: cls._tree_types[(name, color, texture)] = TreeType(name, color, texture) return cls._tree_types[(name, color, texture)] # Context class to store extrinsic state class Tree: def __init__(self, x, y, tree_type): self.x = x # Extrinsic State self.y = y # Extrinsic State self.tree_type = tree_type def display(self): self.tree_type.display(self.x, self.y) # Usage # A forest class containing multiple tree instances class Forest: def __init__(self): self.trees = [] def plant_tree(self, x, y, name, color, texture): tree_type = TreeFactory.get_tree_type(name, color, texture) tree = Tree(x, y, tree_type) self.trees.append(tree) def display_forest(self): for tree in self.trees: tree.display() # Client code forest = Forest() forest.plant_tree(1, 2, \u0026#34;Maple\u0026#34;, \u0026#34;Red\u0026#34;, \u0026#34;Rough\u0026#34;) forest.plant_tree(5, 3, \u0026#34;Oak\u0026#34;, \u0026#34;Green\u0026#34;, \u0026#34;Rough\u0026#34;) forest.plant_tree(10, 1, \u0026#34;Maple\u0026#34;, \u0026#34;Red\u0026#34;, \u0026#34;Rough\u0026#34;) # Reuses Maple tree type forest.display_forest() In this example:\nThe TreeType class represents the flyweight which includes the intrinsic state (name, color, and texture). The Tree class represents the context which has the extrinsic state (x and y coordinates). TreeFactory is used to ensure that for each type of tree, only one TreeType instance is created and shared (flyweight). The display method of TreeType needs the extrinsic state to display the tree, which is provided by the Tree\u0026rsquo;s display method when it is called. When we run this code, the Forest class will plant trees of different types at different locations, but it will reuse the TreeType instances wherever possible, demonstrating the flyweight pattern.\n","permalink":"https://sukhdeepg.github.io/design-patterns/flyweight/","summary":"The flyweight design pattern is a way to save memory by sharing as much data as possible with similar objects. It\u0026rsquo;s like having a library where instead of buying a book every time we want to read it, we just borrow it, read it, and return it. This way, many people can read the book, but there\u0026rsquo;s only one copy that everyone shares.\nIn real world, imagine we have a company that creates business cards.","title":"Flyweight with examples in Python"},{"content":"The Facade Design Pattern is like having a remote control for various devices in our home. Imagine we have a TV, a sound system, and lights in our living room. Instead of turning on each one separately, we use a remote control (the \u0026ldquo;facade\u0026rdquo;) that has a single \u0026ldquo;movie mode\u0026rdquo; button. When we press it, the remote turns on the TV, sets the sound system to the right volume, and dims the lights all at once. The remote simplifies the process by providing one button to control everything, instead of us manually managing each device.\nIn the context of code, a facade is an object that provides a simplified interface to a larger body of code, like a library or a complex system of classes.\nLet\u0026rsquo;s understand this with an example:\n# Complex parts class Engine: def start(self): return \u0026#34;Engine is starting\u0026#34; class AirConditioner: def turn_on(self): return \u0026#34;Air conditioner is on\u0026#34; class Radio: def play_music(self): return \u0026#34;Playing music\u0026#34; # Facade class CarFacade: def __init__(self): self.engine = Engine() self.air_conditioner = AirConditioner() self.radio = Radio() def turn_on_car(self): start_engine = self.engine.start() ac_on = self.air_conditioner.turn_on() music = self.radio.play_music() return f\u0026#34;{start_engine}, {ac_on}, and {music}\u0026#34; def main(): car = CarFacade() print(car.turn_on_car()) if __name__ == \u0026#34;__main__\u0026#34;: main() In this example, CarFacade acts as the remote control. The turn_on_car method is like the \u0026ldquo;movie mode\u0026rdquo; button; it starts the engine, turns on the air conditioner, and starts playing music with one command, hiding the complexity of the individual systems behind a simple interface.\nThe Facade Design Pattern is commonly used in situations where a system is very complex or difficult to understand because it involves a lot of interdependent classes or because its source code is hard to read. In such cases, a facade can provide a simple, easy-to-understand interface over the complex system. Here\u0026rsquo;s a real-world coding scenario where a facade might be used:\nScenario: Email System Integration\nImagine we are developing an application that needs to send out emails. The email sending process involves several complex steps:\nPreparing the email content: This may involve using a template system to insert data into predefined templates and formatting the content for plain text and HTML versions. Attachment handling: If our email has attachments, they need to be encoded and added to the email. SMTP configuration: We need to configure the Simple Mail Transfer Protocol (SMTP) settings, which might include setting up the host, port, user credentials, and encryption methods. Sending the email: This involves establishing a connection to the SMTP server, authenticating, sending the email data, and then handling the response. Error handling: Proper error handling and logging are necessary to understand if the email was sent successfully or if it failed. In a large application, each of these steps might be handled by a different class or library, and interacting with them directly can be quite complicated.\nFacade Implementation:\nTo simplify this for the rest of our application, we could create a EmailFacade class. This facade would provide a simple method such as send_email, which would internally handle all of the steps described above. The rest of our application code only needs to know about this facade and can send emails without worrying about the underlying complexities.\nHere is an abstract representation of what that might look like in code:\nclass EmailFacade: def __init__(self): self.content_creator = EmailContentCreator() self.attachment_handler = AttachmentHandler() self.smtp_configurator = SMTPConfigurator() self.email_sender = EmailSender() self.error_handler = EmailErrorHandler() def send_email(self, to_address, subject, template, data, attachments=None): content = self.content_creator.create_content(template, data) email = self.attachment_handler.add_attachments(content, attachments) smtp_details = self.smtp_configurator.configure_smtp() try: self.email_sender.send(smtp_details, to_address, subject, email) print(\u0026#34;Email sent successfully!\u0026#34;) except Exception as e: self.error_handler.log_error(e) By using the facade, any developer working on the application can send emails easily without having to understand the inner workings of the email system. They just need to know the parameters for the send_email method of the EmailFacade. This not only makes the developer\u0026rsquo;s life easier but also makes the application more maintainable and less prone to errors.\n","permalink":"https://sukhdeepg.github.io/design-patterns/facade/","summary":"The Facade Design Pattern is like having a remote control for various devices in our home. Imagine we have a TV, a sound system, and lights in our living room. Instead of turning on each one separately, we use a remote control (the \u0026ldquo;facade\u0026rdquo;) that has a single \u0026ldquo;movie mode\u0026rdquo; button. When we press it, the remote turns on the TV, sets the sound system to the right volume, and dims the lights all at once.","title":"Facade with examples in Python"},{"content":"The decorator pattern is a design pattern in programming that allows behavior to be added to individual objects, either statically or dynamically, without affecting the behavior of other objects from the same class.\nIn real world, imagine we are decorating a plain Christmas tree. We start with a simple tree, and we add decorations to it such as lights, ornaments, and tinsel. Each decoration enhances the tree by adding a layer of detail without changing its structure. We can add or remove decorations freely without affecting the underlying tree.\nSimilarly, in programming, the decorator pattern is used to \u0026ldquo;decorate\u0026rdquo; objects with additional features or behaviors without changing the object\u0026rsquo;s class. Each decorator adds some functionality, wrapping the original object, just like ornaments wrapping the tree.\nLet\u0026rsquo;s understand this with an example:\nclass Car: def __init__(self): self._description = \u0026#34;Basic Car\u0026#34; def get_description(self): return self._description def get_cost(self): # Cost of the basic car return 10000 Now, let\u0026rsquo;s define some decorators to add features to the car:\nclass PremiumPackageDecorator: def __init__(self, car): self._car = car def get_description(self): return self._car.get_description() + \u0026#34;, with premium package\u0026#34; def get_cost(self): return self._car.get_cost() + 5000 class SportsPackageDecorator: def __init__(self, car): self._car = car def get_description(self): return self._car.get_description() + \u0026#34;, with sports package\u0026#34; def get_cost(self): return self._car.get_cost() + 7000 # Create a basic car my_car = Car() print(my_car.get_description()) print(my_car.get_cost()) # Add premium package my_car = PremiumPackageDecorator(my_car) print(my_car.get_description()) print(my_car.get_cost()) # Add sports package my_car = SportsPackageDecorator(my_car) print(my_car.get_description()) print(my_car.get_cost()) Output:\nBasic Car 10000 Basic Car, with premium package 15000 Basic Car, with premium package, with sports package 22000 In python we have \u0026ldquo;@\u0026rdquo; decorators that we can use on functions.\ndef basic_car_description(): \u0026#34;\u0026#34;\u0026#34;A simple function that returns a basic car\u0026#39;s description.\u0026#34;\u0026#34;\u0026#34; return \u0026#34;Basic Car\u0026#34; def basic_car_cost(): \u0026#34;\u0026#34;\u0026#34;A simple function that returns a basic car\u0026#39;s cost.\u0026#34;\u0026#34;\u0026#34; return 10000 def premium_package(func): \u0026#34;\u0026#34;\u0026#34;Decorator function to add premium package features to a car\u0026#39;s description.\u0026#34;\u0026#34;\u0026#34; def wrapper(*args, **kwargs): return func(*args, **kwargs) + \u0026#34;, with premium package\u0026#34; return wrapper def sports_package(func): \u0026#34;\u0026#34;\u0026#34;Decorator function to add sports package features to a car\u0026#39;s description.\u0026#34;\u0026#34;\u0026#34; def wrapper(*args, **kwargs): return func(*args, **kwargs) + \u0026#34;, with sports package\u0026#34; return wrapper def additional_cost(amount): \u0026#34;\u0026#34;\u0026#34;Decorator function to add additional cost to a car.\u0026#34;\u0026#34;\u0026#34; def decorator(func): def wrapper(*args, **kwargs): return func(*args, **kwargs) + amount return wrapper return decorator # Decorating the functions @premium_package def get_premium_car_description(): return basic_car_description() @additional_cost(5000) def get_premium_car_cost(): return basic_car_cost() @premium_package @sports_package def get_sports_premium_car_description(): return basic_car_description() @additional_cost(12000) def get_sports_premium_car_cost(): return basic_car_cost() print(get_premium_car_description()) print(get_premium_car_cost()) print(get_sports_premium_car_description()) print(get_sports_premium_car_cost()) Output:\nBasic Car, with premium package 15000 Basic Car, with sports package, with premium package 22000 ","permalink":"https://sukhdeepg.github.io/design-patterns/decorator/","summary":"The decorator pattern is a design pattern in programming that allows behavior to be added to individual objects, either statically or dynamically, without affecting the behavior of other objects from the same class.\nIn real world, imagine we are decorating a plain Christmas tree. We start with a simple tree, and we add decorations to it such as lights, ornaments, and tinsel. Each decoration enhances the tree by adding a layer of detail without changing its structure.","title":"Decorator with examples in Python"},{"content":"The Composite Design Pattern is a structural design pattern that lets us compose objects into tree structures to represent part-whole hierarchies. To expand this further: This pattern is all about creating objects that have other objects inside them. Let\u0026rsquo;s break down the last sentence further:\nCompose objects into tree structures: This means that we\u0026rsquo;re making some objects that contain other objects. This is similar to how a family tree works: a parent can have children, and those children can also be parents to their own children. In computer science, this is referred to as a \u0026ldquo;tree\u0026rdquo; structure.\nTo represent part-whole hierarchies: This means that the objects that are inside other objects are considered part of the larger object. It\u0026rsquo;s a way to represent a hierarchy or relationship between things. Like in a car, an engine, wheels, and a body are parts of the car as a whole. The car is the \u0026ldquo;whole\u0026rdquo;, and the engine, wheels, and body are the \u0026ldquo;parts\u0026rdquo;.\nSo in simple terms, the Composite Design Pattern is a way to make complex objects that are made up of other smaller objects, and this pattern allows us to organize these objects in a way that represents a hierarchy or relationship between them.\nLet\u0026rsquo;s understand this with an example:\nfrom abc import ABC, abstractmethod from typing import List class CarComponent(ABC): @abstractmethod def operation(self) -\u0026gt; str: pass class LeafElement(CarComponent): def __init__(self, name): self.name = name def operation(self) -\u0026gt; str: return self.name class Composite(CarComponent): def __init__(self, name) -\u0026gt; None: self.name = name self._children: List[CarComponent] = [] def add(self, component: CarComponent) -\u0026gt; None: self._children.append(component) def remove(self, component: CarComponent) -\u0026gt; None: self._children.remove(component) def operation(self) -\u0026gt; str: results = [] for child in self._children: results.append(child.operation()) return f\u0026#34;{self.name}: {\u0026#39;, \u0026#39;.join(results)}\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: # simple components engine = LeafElement(\u0026#34;Engine\u0026#34;) wheel1 = LeafElement(\u0026#34;Wheel1\u0026#34;) wheel2 = LeafElement(\u0026#34;Wheel2\u0026#34;) wheel3 = LeafElement(\u0026#34;Wheel3\u0026#34;) wheel4 = LeafElement(\u0026#34;Wheel4\u0026#34;) # complex components (composite) wheels = Composite(\u0026#34;Wheels\u0026#34;) car = Composite(\u0026#34;Car\u0026#34;) # tree structure wheels.add(wheel1) wheels.add(wheel2) wheels.add(wheel3) wheels.add(wheel4) car.add(engine) car.add(wheels) print(car.operation()) Output:\nCar: Engine, Wheels: Wheel1, Wheel2, Wheel3, Wheel4 Some real world scenarios where this design pattern can be used:\nFile Systems: A file system is a classic example of a Composite pattern. A directory can contain files or other directories. Here, \u0026lsquo;Directory\u0026rsquo; is a Composite, and \u0026lsquo;File\u0026rsquo; is a Leaf. GUI Widgets: In graphical applications, a container widget (like a window or a panel) can contain other widgets (like buttons and checkboxes) or even other containers. This is another case where the Composite pattern is useful. Hope the post have created some value. Peace!\n","permalink":"https://sukhdeepg.github.io/design-patterns/composite/","summary":"The Composite Design Pattern is a structural design pattern that lets us compose objects into tree structures to represent part-whole hierarchies. To expand this further: This pattern is all about creating objects that have other objects inside them. Let\u0026rsquo;s break down the last sentence further:\nCompose objects into tree structures: This means that we\u0026rsquo;re making some objects that contain other objects. This is similar to how a family tree works: a parent can have children, and those children can also be parents to their own children.","title":"Composite with examples in Python"},{"content":"The Bridge Design Pattern is a structural design pattern that aims to separate what a system does from how it does it, so we can change the \u0026lsquo;what\u0026rsquo; and the \u0026lsquo;how\u0026rsquo; independently.\nIn other words, it organizes code in a way that lets us modify the operations a system can perform (like starting a car engine), and the details of how those operations are performed (like whether it\u0026rsquo;s a petrol or electric engine), separately. This makes the code easier to update and manage.\nIt\u0026rsquo;s helpful when we have a monolithic class and we want to divide it further to simplify maintenance.\nImagine that there are two dimensions: \u0026ldquo;car type\u0026rdquo; and \u0026ldquo;car engine type\u0026rdquo;. If we want to create classes for every possible combination, there will be quite a few (sedan with petrol engine, sedan with electric engine, SUV with petrol engine, SUV with electric engine, etc.). Instead, we can separate these two dimensions into different class hierarchies, and then combine them - effectively \u0026ldquo;building a bridge\u0026rdquo; between \u0026ldquo;car type\u0026rdquo; and \u0026ldquo;car engine type\u0026rdquo;.\nLet\u0026rsquo;s understand this with an example:\nfrom abc import ABC, abstractmethod class Engine(ABC): @abstractmethod def start_engine(self): pass class PetrolEngine(Engine): def start_engine(self): return \u0026#34;Starting the petrol engine\u0026#34; class ElectricEngine(Engine): def start_engine(self): return \u0026#34;Starting the electric engine\u0026#34; class Car(ABC): def __init__(self, engine: Engine): self._engine = engine @abstractmethod def start_car(self): pass class Sedan(Car): def start_car(self): return f\u0026#34;Sedan: {self._engine.start_engine()}\u0026#34; class SUV(Car): def start_car(self): return f\u0026#34;SUV: {self._engine.start_engine()}\u0026#34; sedan_with_petrol_engine = Sedan(PetrolEngine()) suv_with_electric_engine = SUV(ElectricEngine()) print(sedan_with_petrol_engine.start_car()) print(suv_with_electric_engine.start_car()) Output:\nSedan: Starting the petrol engine SUV: Starting the electric engine In this code, Car and Engine are the two dimensions. Car is the \u0026lsquo;abstraction\u0026rsquo; and Engine is the \u0026lsquo;implementation\u0026rsquo;. This way, adding a new car type or a new engine type does not affect each other.\nThe Bridge Design Pattern is handy in many scenarios where we want to keep the high-level operations in a system separate from the low-level details. This pattern is used in GUI systems to support multiple operating systems, in software to communicate using different protocols with hardware devices, in database interactions to support various types of databases, and in media players to decode different file formats. Essentially, the Bridge pattern is about segregating \u0026ldquo;what\u0026rdquo; a system does from \u0026ldquo;how\u0026rdquo; it does it, allowing both to evolve independently.\nHope the post have created some value. Peace!\n","permalink":"https://sukhdeepg.github.io/design-patterns/bridge/","summary":"The Bridge Design Pattern is a structural design pattern that aims to separate what a system does from how it does it, so we can change the \u0026lsquo;what\u0026rsquo; and the \u0026lsquo;how\u0026rsquo; independently.\nIn other words, it organizes code in a way that lets us modify the operations a system can perform (like starting a car engine), and the details of how those operations are performed (like whether it\u0026rsquo;s a petrol or electric engine), separately.","title":"Bridge with examples in Python"},{"content":"The adapter design pattern is a structural design pattern that allows objects that don\u0026rsquo;t initially know how to interact with each other (due to differences in their communication methods) to still cooperate. This pattern introduces a wrapper class (an \u0026ldquo;adapter\u0026rdquo;) which translates the interface of one class into an interface expected by clients.\nIn real world, when one of our electrical appliance has a plug that won\u0026rsquo;t fit in the socket due to the appliance having different norm than the other appliances, we make use of an adapter to overcome this and use the appliance. Here, this adapter is the adapter pattern.\nLet\u0026rsquo;s understand this with an example:\nclass Car: def __init__(self, model): self.model = model def start_engine(self): return f\u0026#34;{self.model}\u0026#39;s engine started.\u0026#34; def refuel(self): return f\u0026#34;Refuelling {self.model}.\u0026#34; Here, we have an ElectricCar with different interface than the Car:\nclass ElectricCar: def __init__(self, model): self.model = model def start_electric_engine(self): return f\u0026#34;{self.model}\u0026#39;s electric engine started.\u0026#34; def recharge_battery(self): return f\u0026#34;Recharging {self.model}.\u0026#34; Our existing system doesn\u0026rsquo;t know how to interact with ElectricCar object as it only knows how to work with Car object. To solve this, we\u0026rsquo;ll use the Adapter design pattern.\nLet\u0026rsquo;s create an ElectricCarAdapter because here we can see that Car and ElectricCar have similar purpose.\nclass ElectricCarAdapter: def __init__(self, electric_car): self.electric_car = electric_car def start_engine(self): return self.electric_car.start_electric_engine() def refuel(self): return self.electric_car.recharge_battery() Now, we can use ElectricCar object in the existing system similar to Car object.\ndef client_code(car): print(car.start_engine()) print(car.refuel()) if __name__ == \u0026#34;__main__\u0026#34;: my_car = Car(\u0026#34;PetrolCar\u0026#34;) client_code(my_car) my_electric_car = ElectricCarAdapter(ElectricCar(\u0026#34;ModernEV\u0026#34;)) client_code(my_electric_car) Output:\nPetrolCar\u0026#39;s engine started. Refuelling PetrolCar. ModernEV\u0026#39;s electric engine started. Recharging ModernEV. Here, we saw that how Adapter pattern can enable code to work with classes that otherwise wouldn\u0026rsquo;t be compatible due to their interfaces.\nSome real world scenarios where Adapter pattern could be used:\nLegacy and modern systems: When there is a need to integrate our modern system with a very old legacy system where rewritting the complete legacy system is not feasible, we can use the Adapter pattern to create an interface to enable interaction between legacy and modern systems.\nWorking with Third-Party libraries: Sometimes, a library has an interface that doesn’t match our system’s interface. An adapter class can help translate the interface of the third-party library to the interface our system expects.\nHope the post have created some value. Peace!\n","permalink":"https://sukhdeepg.github.io/design-patterns/adapter/","summary":"The adapter design pattern is a structural design pattern that allows objects that don\u0026rsquo;t initially know how to interact with each other (due to differences in their communication methods) to still cooperate. This pattern introduces a wrapper class (an \u0026ldquo;adapter\u0026rdquo;) which translates the interface of one class into an interface expected by clients.\nIn real world, when one of our electrical appliance has a plug that won\u0026rsquo;t fit in the socket due to the appliance having different norm than the other appliances, we make use of an adapter to overcome this and use the appliance.","title":"Adapter with examples in Python"},{"content":"Singleton design pattern is a type of creational pattern which we use when we need to provide global access to an object. Basically, a class will only have one object.\nLet\u0026rsquo;s understand the above with an example:\nclass Singleton(type): _instances = {} def __call__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls] = super().__call__(*args, **kwargs) return cls._instances[cls] class Car(metaclass=Singleton): def __init__(self, make, model, year): self.make = make self.model = model self.year = year car1 = Car(\u0026#34;Company1\u0026#34;, \u0026#34;Car1\u0026#34;, 2023) car2 = Car(\u0026#34;Company2\u0026#34;, \u0026#34;Car2\u0026#34;, 2023) print(car1 is car2) Output:\nTrue Here, Singleton is a metaclass that ensures that we only ever create one instance of Car. When we call Car() to create an instance, the call method of the metaclass is invoked. If an instance of Car doesn\u0026rsquo;t exist, it creates one and stores it in _instances. If it already exists, it returns the existing one.\nPractical applications of Singleton design pattern includes creating object for logging, DB connection, shared resources (e.g. class having a counter), etc. This helps us ensure consistency.\nHope the post have created some value. Peace!\n","permalink":"https://sukhdeepg.github.io/design-patterns/singleton/","summary":"Singleton design pattern is a type of creational pattern which we use when we need to provide global access to an object. Basically, a class will only have one object.\nLet\u0026rsquo;s understand the above with an example:\nclass Singleton(type): _instances = {} def __call__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls] = super().__call__(*args, **kwargs) return cls._instances[cls] class Car(metaclass=Singleton): def __init__(self, make, model, year): self.make = make self.model = model self.","title":"Singleton with examples in Python"},{"content":"The Prototype Design Pattern is a creational design pattern that involves duplicating or \u0026ldquo;cloning\u0026rdquo; existing objects to create new ones, rather than creating new objects from scratch. This is useful when object creation is time-consuming or complex. This means, instead of creating a new object and setting it up, we make a copy of an existing object and modify it as needed.\nLet\u0026rsquo;s understand the above with an example:\nimport copy class Car: def __init__(self, model, color, engine): self.model = model self.color = color self.engine = engine def clone(self): return copy.deepcopy(self) def __str__(self): return f\u0026#39;{self.color} {self.model} with a {self.engine} engine\u0026#39; if __name__ == \u0026#34;__main__\u0026#34;: car1 = Car(\u0026#39;car1\u0026#39;, \u0026#39;red\u0026#39;, \u0026#39;electric\u0026#39;) print(car1) car2 = car1.clone() car2.model = \u0026#39;car2\u0026#39; car2.color = \u0026#39;blue\u0026#39; print(car2) Output:\nred car1 with a electric engine blue car2 with a electric engine In the above example, we first create a Car object from scratch, i.e., car1 has a red color and electric engine. Now, we need a similar Car object that has a different model and color. So, instead of creating the car2 object from scratch, we just make a copy of the car1 object and make the modifications. In this case, car1 is the prototype for car2.\nBut, why do we need to clone an object? we can always create a new object right?\nIn most cases, creating a new object is the straightforward approach. However, Prototype pattern is useful when creating a new object is resource-intensive, such as when it requires a significant amount of computation, disk reads, network calls, etc. Also when we have an object in a certain state and we need another object just like it.\nHope the post have created some value. Peace!\n","permalink":"https://sukhdeepg.github.io/design-patterns/prototype/","summary":"The Prototype Design Pattern is a creational design pattern that involves duplicating or \u0026ldquo;cloning\u0026rdquo; existing objects to create new ones, rather than creating new objects from scratch. This is useful when object creation is time-consuming or complex. This means, instead of creating a new object and setting it up, we make a copy of an existing object and modify it as needed.\nLet\u0026rsquo;s understand the above with an example:\nimport copy class Car: def __init__(self, model, color, engine): self.","title":"Prototype with examples in Python"},{"content":"The Builder design pattern is a method for constructing complex objects step-by-step, allowing you to create different configurations or variations of the object without altering the main class representing the object. It simplifies object creation by providing a clear and flexible way to build objects with multiple options or components.\nLet\u0026rsquo;s understand the above with an example:\nclass CarBuilder: def __init__(self): self.car = Car() def set_wheels(self, wheels): self.car.wheels = wheels return self def set_color(self, color): self.car.color = color return self def set_seats(self, seats): self.car.seats = seats return self def build(self): return self.car class Car: def __init__(self): self.wheels = None self.color = None self.seats = None def __str__(self): return f\u0026#34;Car with {self.wheels} wheels, {self.color} color, and {self.seats} seats.\u0026#34; builder = CarBuilder() builder.set_wheels(4) builder.set_color(\u0026#34;blue\u0026#34;) builder.set_seats(4) car = builder.build() print(car) The output:\nCar with 4 wheels, blue color, and 4 seats. Here, CarBuilder is responsible for building the Car object. It will set the number of wheels, color and number of seats. The build method will return the final object.\nBut, why do we need the CarBuilder here? We can just put all of this in the Car class itself. The builder pattern becomes useful in cases where the Car class has many optional or complex configurations. So, instead of creating multiple subclasses or sending multiple variables in the constructor, the CarBuilder way is more easy to read and maintain.\nHope the post have created some value. Peace!\n","permalink":"https://sukhdeepg.github.io/design-patterns/builder/","summary":"The Builder design pattern is a method for constructing complex objects step-by-step, allowing you to create different configurations or variations of the object without altering the main class representing the object. It simplifies object creation by providing a clear and flexible way to build objects with multiple options or components.\nLet\u0026rsquo;s understand the above with an example:\nclass CarBuilder: def __init__(self): self.car = Car() def set_wheels(self, wheels): self.car.wheels = wheels return self def set_color(self, color): self.","title":"Builder with examples in Python"},{"content":"Abstract Factory is a creational design pattern that helps create groups of related objects without knowing their specific classes. It\u0026rsquo;s particularly useful when we need to create objects that belong to a family, but we don\u0026rsquo;t care about the specific implementation.\nFirst, let\u0026rsquo;s understand create groups of related objects without knowing their specific classes with a small example:\nclass ShapeFactory: def create_shape(self, shape_type): if shape_type == \u0026#39;circle\u0026#39;: return Circle() elif shape_type == \u0026#39;square\u0026#39;: return Square() elif shape_type == \u0026#39;triangle\u0026#39;: return Triangle() factory = ShapeFactory() shape1 = factory.create_shape(\u0026#39;circle\u0026#39;) shape2 = factory.create_shape(\u0026#39;square\u0026#39;) Here, ShapeFactory creates related shape objects (circles, squares, triangles) without needing to know their specific classes, as it relies on the shape_type parameter.\nThe statement when we need to create objects that belong to a family, but we don\u0026rsquo;t care about the specific implementation simply means that we want to create objects that share a common behavior, without focusing on the details of how they\u0026rsquo;re built. Let\u0026rsquo;s see a small example:\nclass Shape(ABC): @abstractmethod def draw(self): pass class Circle(Shape): def draw(self): return \u0026#34;Drawing a circle\u0026#34; class Square(Shape): def draw(self): return \u0026#34;Drawing a square\u0026#34; Here, we\u0026rsquo;re creating shapes that belong to the Shape family. We don\u0026rsquo;t care about the specific implementation (e.g., how the circle or square is drawn) but we care about the common interface (the draw method). The ShapeFactory creates the objects, and we can use them without knowing their details:\nfactory = ShapeFactory() shape1 = factory.create_shape(\u0026#39;circle\u0026#39;) shape2 = factory.create_shape(\u0026#39;square\u0026#39;) shape1.draw() # Output: Drawing a circle shape2.draw() # Output: Drawing a square One can create and use shapes without knowing their specific classes or implementations, focusing on their shared behavior through the Shape interface.\nNow, let\u0026rsquo;s understand everything together with the following example:\nfrom abc import ABC from abc import abstractmethod class Engine(ABC): @abstractmethod def description(self): pass class Car(ABC): @abstractmethod def assemble(self): pass Concrete classes for Hybrid, Electric, and Gasoline engines:\nclass HybridEngine(Engine): def description(self): return \u0026#34;hybrid engine\u0026#34; class ElectricEngine(Engine): def description(self): return \u0026#34;electric engine\u0026#34; class GasolineEngine(Engine): def description(self): return \u0026#34;gasoline engine\u0026#34; Implementing concrete classes for Car with different engines:\nclass HybridCar(Car): def __init__(self, engine: Engine): self.engine = engine def assemble(self): return f\u0026#34;Assembling a car with a {self.engine.description()}\u0026#34; class ElectricCar(Car): def __init__(self, engine: Engine): self.engine = engine def assemble(self): return f\u0026#34;Assembling a car with a {self.engine.description()}\u0026#34; class GasolineCar(Car): def __init__(self, engine: Engine): self.engine = engine def assemble(self): return f\u0026#34;Assembling a car with a {self.engine.description()}\u0026#34; Abstract Factory for creating cars:\nclass CarFactory(ABC): @abstractmethod def create_car(self) -\u0026gt; Car: pass Concrete factory classes for Hybrid, Electric, and Gasoline cars:\nclass HybridCarFactory(CarFactory): def create_car(self) -\u0026gt; Car: return HybridCar(HybridEngine()) class ElectricCarFactory(CarFactory): def create_car(self) -\u0026gt; Car: return ElectricCar(ElectricEngine()) class GasolineCarFactory(CarFactory): def create_car(self) -\u0026gt; Car: return GasolineCar(GasolineEngine()) putting everything together:\ndef client_code(car_factory: CarFactory): car = car_factory.create_car() print(car.assemble()) hybrid_factory = HybridCarFactory() electric_factory = ElectricCarFactory() gasoline_factory = GasolineCarFactory() client_code(hybrid_factory) # Output: Assembling a car with a hybrid engine client_code(electric_factory) # Output: Assembling a car with a electric engine client_code(gasoline_factory) # Output: Assembling a car with a gasoline engine The Abstract Factory pattern allows us to create cars with different engines without specifying their concrete classes, making it easy to add new types of engines or cars in the future.\nNow, let\u0026rsquo;s understand the difference between Abstract Factory and Factory Method.\nAbstract Factory: It\u0026rsquo;s about creating families of related objects. Abstract Factory contains multiple Factory Methods for creating different types of products. Clients use the factory object to create objects of different types that belong to a specific family. Factory Method: It\u0026rsquo;s about creating one type of object. Factory Method defines a single method for object creation. Subclasses decide which class to instantiate. Clients use the Factory Method to create objects without knowing the actual class being instantiated. In summary, Abstract Factory is an extension of Factory Method that can create multiple related objects, while Factory Method focuses on creating a single type of object.\nHope the post have created some value. Peace!\n","permalink":"https://sukhdeepg.github.io/design-patterns/abstract-factory/","summary":"Abstract Factory is a creational design pattern that helps create groups of related objects without knowing their specific classes. It\u0026rsquo;s particularly useful when we need to create objects that belong to a family, but we don\u0026rsquo;t care about the specific implementation.\nFirst, let\u0026rsquo;s understand create groups of related objects without knowing their specific classes with a small example:\nclass ShapeFactory: def create_shape(self, shape_type): if shape_type == \u0026#39;circle\u0026#39;: return Circle() elif shape_type == \u0026#39;square\u0026#39;: return Square() elif shape_type == \u0026#39;triangle\u0026#39;: return Triangle() factory = ShapeFactory() shape1 = factory.","title":"Abstract Factory with examples in Python"},{"content":"The Factory Method is a creational design pattern which is great for managing object creation in a clean, modular, and scalable way. It promotes loose coupling and code reusability. This pattern comes handy when we have multiple object types with a shared interface or base class, and we want to create new objects based on a given parameter without hardcoding the exact classes.\nWhat exactly does factory mean? \u0026ldquo;Factory\u0026rdquo; refers to an object that is responsible for creating another object. In real world factories, we input raw materials and design specfication and we get goods as an output. Here, we input a type or a set of parameters and we get an object as an output. Let\u0026rsquo;s understand the above with an example:\nfrom abc import ABC from abc import abstractmethod class Car(ABC): @abstractmethod def start(self): pass class ElectricCar(Car): def start(self): return \u0026#34;Starting electric car!\u0026#34; class GasolineCar(Car): def start(self): return \u0026#34;Starting gasoline car!\u0026#34; class HybridCar(Car): def start(self): return \u0026#34;Starting hybrid car!\u0026#34; Here, the ElectricCar, GasolineCar, and HybridCar, extends the Car abstract base class. This means the start method needs to be implemented. Now, we\u0026rsquo;ll create Car Factory.\nclass CarFactory: def __init__(self): self._car_map = {} def create_car(self, car_type): car_class = self._car_map.get(car_type) if car_class: return car_class() else: raise ValueError(f\u0026#34;Invalid car type: {car_type}\u0026#34;) def register_car(self, car_type, car_class): self._car_map[car_type] = car_class Now, we can create car objects based on the car_type parameter without hardcoding the exact classes. def main(): car_factory = CarFactory() car_factory.register_car(\u0026#34;electric\u0026#34;, ElectricCar) car_factory.register_car(\u0026#34;gasoline\u0026#34;, GasolineCar) car_factory.register_car(\u0026#34;hybrid\u0026#34;, HybridCar) electric_car = car_factory.create_car(\u0026#34;electric\u0026#34;) print(electric_car.start()) gasoline_car = car_factory.create_car(\u0026#34;gasoline\u0026#34;) print(gasoline_car.start()) hybrid_car = car_factory.create_car(\u0026#34;hybrid\u0026#34;) print(hybrid_car.start()) if __name__ == \u0026#34;__main__\u0026#34;: main() The output:\nStarting electric car! Starting gasoline car! Starting hybrid car! Now, the above has few benefits:\nDecoupling: CarFactory decouples the creation of car objects from their usage. Client doesn\u0026rsquo;t need to know about the concrete car classes (ElectricCar, GasolineCar, and HybridCar). This helps make code more modular and easy to maintain. Extensibility: If we need to add a new car type, we can simply create a new class for the car type, extend Car abstract base class, and register the car type with CarFactory. This helps adding new car types without affecting the existing code. Hope the post have created some value. Peace!\n","permalink":"https://sukhdeepg.github.io/design-patterns/factory-method/","summary":"The Factory Method is a creational design pattern which is great for managing object creation in a clean, modular, and scalable way. It promotes loose coupling and code reusability. This pattern comes handy when we have multiple object types with a shared interface or base class, and we want to create new objects based on a given parameter without hardcoding the exact classes.\nWhat exactly does factory mean? \u0026ldquo;Factory\u0026rdquo; refers to an object that is responsible for creating another object.","title":"Factory Method with examples in Python"},{"content":"When we start our programming journey, with continuous practice and learning, writing code becomes easier. But, as we advance in our careers, it becomes equally important to learn how to maintain and help others maintain what we are writing. 1. Single Responsibility Principle Easy to understand. Every module, class, or function should only have a single responsibility or only one reason to change. But it’s difficult to practically implement because lines can get blurry during implementation.\nTo simplify this, Uncle Bob says that \u0026ldquo;This principle is about people\u0026rdquo; in this blog.\nLet’s understand with an example\nclass Payment: # process the payment def process(self): pass # save the payment def save(self): pass # retrieve the payment information def retrieve(self): pass # return analytics data related to payment. E.g. processing time of payment def analytics(self): pass # check if the information for payment is correct or not. E.g. card number, CVV, etc def check(self): pass As we can see, this class is performing a lot of functions for a given payment and has more than one reason to change. What if we have different people using these functionalities? If one person thinks to change the check function logic and return field to bool mapping dict e.g {“is_cvv_valid”: True} instead of list of field and bool tuple e.g. [(\u0026quot;is_cvv_valid\u0026quot;, True)], this will affect the processing logic and eventually, analytics will create panic!\nIt will be better if each functionality is isolated and handled by a single team or individual in order to avoid any dependency and compatibility issues. Each functionality will have a standard output format. So, even if the internal logic changes for a functionality, it won’t affect the other dependent functionalities and will also have a single responsibility and reason to change. This will make the code more cohesive and easier to maintain.\nclass ProcessPayment: def process(self): pass class SavePayment: def save(self): pass class RetrievePayment: def retrieve(self): pass class AnalyticsPayment: def analytics(self): pass class SecCheckPayment: def security_check(self): pass 2. Open-closed Principle Open for extension but closed for modification. Extension means that we’re extending the functionality of our code. Modification means that we’re modifying our existing code.\nNow, which sounds more risky? modification, right? Because when we write our code, test it, and deploy it, we should not go back and modify it, as this can lead to instability, create bugs, etc.\nIn Python (and in many other languages), we can make use of an abstract base class to help us extend the functionality of our code.\nLet’s understand with an example\nfrom abc import ABC, abstractmethod class Hardware(ABC): @abstractmethod def functionality(): pass class Monitor(Hardware): def functionality(self): print(\u0026#39;To display information on the screen.\u0026#39;) class Mouse(Hardware): def functionality(self): print(\u0026#39;To move cursor on the screen and click on elements.\u0026#39;) class Keyboard(Hardware): def functionality(self): print(\u0026#39;To help type the required information.\u0026#39;) mon = Monitor() mou = Mouse() key = Keyboard() mon.functionality() mou.functionality() key.functionality() Here, if we need to add functionality for Printer, we don’t need to modify any existing class or function, we can simply extend the Hardware class and create the functionality.\nclass Printer(Hardware): def functionality(self): print(\u0026#39;To print information on the paper.\u0026#39;) 3. Liskov Substitution Principle If we have an object of superclass (A) and an object of child class (B), then we should be able to replace A with B without affecting the existing behaviour of the program.\nContinuing the example from the Open-closed principle, if we want to create a function that takes the Hardware and prints its functionality, we don’t want to create if elif else condition blocks to decide what to print. Instead, it will be much cleaner to create a generic function that just takes an object and prints the functionality.\nfrom abc import ABC, abstractmethod class Hardware(ABC): @abstractmethod def functionality(): pass class Monitor(Hardware): def functionality(self): print(\u0026#39;To display information on the screen.\u0026#39;) class Mouse(Hardware): def functionality(self): print(\u0026#39;To move cursor on the screen and click on elements.\u0026#39;) class Keyboard(Hardware): def functionality(self): print(\u0026#39;To help type the required information.\u0026#39;) class Printer(Hardware): def functionality(self): print(\u0026#39;To print information on the paper.\u0026#39;) def print_functionality(h: Hardware): h.functionality() mon = Monitor() mou = Mouse() key = Keyboard() pri = Printer() print_functionality(mon) print_functionality(mou) print_functionality(key) print_functionality(pri) In the print_functionality function, we can easily replace the object of the Hardware class with objects of the Monitor, Mouse, Keyboard, Printer classes. 4. Interface Segregation Principle The interface segregation principle (ISP) states that no code should be forced to depend on methods it does not use. Source.\nIf we add the firmware_update function to our Hardware class, it would mean that, all our child classes would need to have the firmware_update function.\nclass Hardware(ABC): @abstractmethod def functionality(): pass @abstractmethod def firmware_update(): pass Now, this firmware_update function will not be used by the mouse and keyboard usually. So, why do these classes even need to have this function? This violates the ISP. To avoid this, we can have the following update\nfrom abc import ABC, abstractmethod class Hardware(ABC): @abstractmethod def functionality(): pass class Firmware(ABC): @abstractmethod def update(): pass class Monitor(Hardware, Firmware): def functionality(self): print(\u0026#39;To display information on the screen.\u0026#39;) def update(): print(\u0026#39;Updating firmware.\u0026#39;) class Mouse(Hardware): def functionality(self): print(\u0026#39;To move cursor on the screen and click on elements.\u0026#39;) class Keyboard(Hardware): def functionality(self): print(\u0026#39;To help type the required information.\u0026#39;) class Printer(Hardware, Firmware): def functionality(self): print(\u0026#39;To print information on the paper.\u0026#39;) def update(self): print(\u0026#39;Updating firmware.\u0026#39;) 5. Dependency Inversion Principle High-level modules or classes should not depend on low-level modules (concrete implementations) or classes. High-modules should depend on abstractions or interfaces.\nLet’s see example for high-level and low-level class\nfrom abc import ABC, abstractmethod class MusicPlayer: def play(self): music_service_a = MusicServiceA() music_service_a.play() class MusicServiceA: def play(self): print(\u0026#39;Playing music from MusicServiceA.\u0026#39;) mp = MusicPlayer() mp.play() MusicPlayer is the high-level class and MusicServiceA is the low-level class. Here, MusicPlayer is directly dependent on the MusicServiceA class. If tomorrow, we need another service to play music from, we would need to modify the MusicPlayer class which violates the OCP. To avoid this dependency, we can create a MusicService abstract class and pass it to the MusicPlayer.\nfrom abc import ABC, abstractmethod class MusicPlayer: def __init__(self, music_service): self.music_service = music_service def play(self): self.music_service.play() class MusicService(ABC): @abstractmethod def play(self): pass class MusicServiceA(MusicService): def play(self): print(\u0026#39;Playing music from MusicServiceA.\u0026#39;) class MusicServiceB(MusicService): def play(self): print(\u0026#39;Playing music from MusicServiceB.\u0026#39;) msa = MusicServiceA() msb = MusicServiceB() mp1 = MusicPlayer(msa) mp2 = MusicPlayer(msb) mp1.play() mp2.play() Conclusion We covered all the SOLID principles with Python examples (dos and don\u0026rsquo;ts) and simplified the definitions associated with the principles.\nHope the post have created some value. Peace!\n","permalink":"https://sukhdeepg.github.io/design-patterns/solid/","summary":"When we start our programming journey, with continuous practice and learning, writing code becomes easier. But, as we advance in our careers, it becomes equally important to learn how to maintain and help others maintain what we are writing. 1. Single Responsibility Principle Easy to understand. Every module, class, or function should only have a single responsibility or only one reason to change. But it’s difficult to practically implement because lines can get blurry during implementation.","title":"SOLID Principles with examples in Python"}]