<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>ðŸ’¾</title>
    <link>https://sukhdeepg.github.io/</link>
    <description>Recent content on ðŸ’¾</description>
    <image>
      <title>ðŸ’¾</title>
      <url>https://sukhdeepg.github.io/</url>
      <link>https://sukhdeepg.github.io/</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 13 Jun 2023 20:28:09 +0530</lastBuildDate><atom:link href="https://sukhdeepg.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Composite with examples in Python</title>
      <link>https://sukhdeepg.github.io/posts/composite/</link>
      <pubDate>Tue, 13 Jun 2023 20:28:09 +0530</pubDate>
      
      <guid>https://sukhdeepg.github.io/posts/composite/</guid>
      <description>The Composite Design Pattern is a structural design pattern that lets us compose objects into tree structures to represent part-whole hierarchies. To expand this further: This pattern is all about creating objects that have other objects inside them. Let&amp;rsquo;s break down the last sentence further:
Compose objects into tree structures: This means that we&amp;rsquo;re making some objects that contain other objects. This is similar to how a family tree works: a parent can have children, and those children can also be parents to their own children.</description>
    </item>
    
    <item>
      <title>Bridge with examples in Python</title>
      <link>https://sukhdeepg.github.io/posts/bridge/</link>
      <pubDate>Tue, 06 Jun 2023 22:26:39 +0530</pubDate>
      
      <guid>https://sukhdeepg.github.io/posts/bridge/</guid>
      <description>The Bridge Design Pattern is a structural design pattern that aims to separate what a system does from how it does it, so we can change the &amp;lsquo;what&amp;rsquo; and the &amp;lsquo;how&amp;rsquo; independently.
In other words, it organizes code in a way that lets us modify the operations a system can perform (like starting a car engine), and the details of how those operations are performed (like whether it&amp;rsquo;s a petrol or electric engine), separately.</description>
    </item>
    
    <item>
      <title>Adapter with examples in Python</title>
      <link>https://sukhdeepg.github.io/posts/adapter/</link>
      <pubDate>Wed, 24 May 2023 09:33:49 +0530</pubDate>
      
      <guid>https://sukhdeepg.github.io/posts/adapter/</guid>
      <description>The adapter design pattern is a structural design pattern that allows objects that don&amp;rsquo;t initially know how to interact with each other (due to differences in their communication methods) to still cooperate. This pattern introduces a wrapper class (an &amp;ldquo;adapter&amp;rdquo;) which translates the interface of one class into an interface expected by clients.
In real world, when one of our electrical appliance has a plug that won&amp;rsquo;t fit in the socket due to the appliance having different norm than the other appliances, we make use of an adapter to overcome this and use the appliance.</description>
    </item>
    
    <item>
      <title>Singleton with examples in Python</title>
      <link>https://sukhdeepg.github.io/posts/singleton/</link>
      <pubDate>Tue, 16 May 2023 21:40:50 +0530</pubDate>
      
      <guid>https://sukhdeepg.github.io/posts/singleton/</guid>
      <description>Singleton design pattern is a type of creational pattern which we use when we need to provide global access to an object. Basically, a class will only have one object.
Let&amp;rsquo;s understand the above with an example:
class Singleton(type): _instances = {} def __call__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls] = super().__call__(*args, **kwargs) return cls._instances[cls] class Car(metaclass=Singleton): def __init__(self, make, model, year): self.make = make self.model = model self.</description>
    </item>
    
    <item>
      <title>Prototype with examples in Python</title>
      <link>https://sukhdeepg.github.io/posts/prototype/</link>
      <pubDate>Fri, 12 May 2023 14:33:06 +0530</pubDate>
      
      <guid>https://sukhdeepg.github.io/posts/prototype/</guid>
      <description>The Prototype Design Pattern is a creational design pattern that involves duplicating or &amp;ldquo;cloning&amp;rdquo; existing objects to create new ones, rather than creating new objects from scratch. This is useful when object creation is time-consuming or complex. This means, instead of creating a new object and setting it up, we make a copy of an existing object and modify it as needed.
Let&amp;rsquo;s understand the above with an example:
import copy class Car: def __init__(self, model, color, engine): self.</description>
    </item>
    
    <item>
      <title>Builder with examples in Python</title>
      <link>https://sukhdeepg.github.io/posts/builder/</link>
      <pubDate>Mon, 08 May 2023 23:06:55 +0530</pubDate>
      
      <guid>https://sukhdeepg.github.io/posts/builder/</guid>
      <description>The Builder design pattern is a method for constructing complex objects step-by-step, allowing you to create different configurations or variations of the object without altering the main class representing the object. It simplifies object creation by providing a clear and flexible way to build objects with multiple options or components.
Let&amp;rsquo;s understand the above with an example:
class CarBuilder: def __init__(self): self.car = Car() def set_wheels(self, wheels): self.car.wheels = wheels return self def set_color(self, color): self.</description>
    </item>
    
    <item>
      <title>Abstract Factory with examples in Python</title>
      <link>https://sukhdeepg.github.io/posts/abstract-factory/</link>
      <pubDate>Sun, 07 May 2023 14:44:52 +0530</pubDate>
      
      <guid>https://sukhdeepg.github.io/posts/abstract-factory/</guid>
      <description>Abstract Factory is a creational design pattern that helps create groups of related objects without knowing their specific classes. It&amp;rsquo;s particularly useful when we need to create objects that belong to a family, but we don&amp;rsquo;t care about the specific implementation.
First, let&amp;rsquo;s understand create groups of related objects without knowing their specific classes with a small example:
class ShapeFactory: def create_shape(self, shape_type): if shape_type == &amp;#39;circle&amp;#39;: return Circle() elif shape_type == &amp;#39;square&amp;#39;: return Square() elif shape_type == &amp;#39;triangle&amp;#39;: return Triangle() factory = ShapeFactory() shape1 = factory.</description>
    </item>
    
    <item>
      <title>Factory Method with examples in Python</title>
      <link>https://sukhdeepg.github.io/posts/factory-method/</link>
      <pubDate>Mon, 01 May 2023 11:10:03 +0530</pubDate>
      
      <guid>https://sukhdeepg.github.io/posts/factory-method/</guid>
      <description>The Factory Method is a creational design pattern which is great for managing object creation in a clean, modular, and scalable way. It promotes loose coupling and code reusability. This pattern comes handy when we have multiple object types with a shared interface or base class, and we want to create new objects based on a given parameter without hardcoding the exact classes.
What exactly does factory mean? &amp;ldquo;Factory&amp;rdquo; refers to an object that is responsible for creating another object.</description>
    </item>
    
    <item>
      <title>SOLID Principles with examples in Python</title>
      <link>https://sukhdeepg.github.io/posts/solid/</link>
      <pubDate>Tue, 21 Mar 2023 23:07:07 +0530</pubDate>
      
      <guid>https://sukhdeepg.github.io/posts/solid/</guid>
      <description>When we start our programming journey, with continuous practice and learning, writing code becomes easier. But, as we advance in our careers, it becomes equally important to learn how to maintain and help others maintain what we are writing. 1. Single Responsibility Principle Easy to understand. Every module, class, or function should only have a single responsibility or only one reason to change. But itâ€™s difficult to practically implement because lines can get blurry during implementation.</description>
    </item>
    
    
  </channel>
</rss>
