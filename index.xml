<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Sukhdeep&#39;s Blog</title>
    <link>https://sukhdeepg.github.io/</link>
    <description>Recent content on Sukhdeep&#39;s Blog</description>
    <image>
      <title>Sukhdeep&#39;s Blog</title>
      <url>https://sukhdeepg.github.io/</url>
      <link>https://sukhdeepg.github.io/</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 07 May 2023 14:44:52 +0530</lastBuildDate><atom:link href="https://sukhdeepg.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Abstract Factory with examples in Python</title>
      <link>https://sukhdeepg.github.io/posts/abstract-factory/</link>
      <pubDate>Sun, 07 May 2023 14:44:52 +0530</pubDate>
      
      <guid>https://sukhdeepg.github.io/posts/abstract-factory/</guid>
      <description>Abstract Factory is a creational design pattern that helps create groups of related objects without knowing their specific classes. It&amp;rsquo;s particularly useful when we need to create objects that belong to a family, but we don&amp;rsquo;t care about the specific implementation.
First, let&amp;rsquo;s understand create groups of related objects without knowing their specific classes with a small example:
class ShapeFactory: def create_shape(self, shape_type): if shape_type == &amp;#39;circle&amp;#39;: return Circle() elif shape_type == &amp;#39;square&amp;#39;: return Square() elif shape_type == &amp;#39;triangle&amp;#39;: return Triangle() factory = ShapeFactory() shape1 = factory.</description>
    </item>
    
    <item>
      <title>Factory Method with examples in Python</title>
      <link>https://sukhdeepg.github.io/posts/factory-method/</link>
      <pubDate>Mon, 01 May 2023 11:10:03 +0530</pubDate>
      
      <guid>https://sukhdeepg.github.io/posts/factory-method/</guid>
      <description>The Factory Method is a creational design pattern which is great for managing object creation in a clean, modular, and scalable way. It promotes loose coupling and code reusability. This pattern comes handy when we have multiple object types with a shared interface or base class, and we want to create new objects based on a given parameter without hardcoding the exact classes. Let&amp;rsquo;s understand the above with an example:</description>
    </item>
    
    <item>
      <title>SOLID Principles with examples in Python</title>
      <link>https://sukhdeepg.github.io/posts/solid/</link>
      <pubDate>Tue, 21 Mar 2023 23:07:07 +0530</pubDate>
      
      <guid>https://sukhdeepg.github.io/posts/solid/</guid>
      <description>When we start our programming journey, with continuous practice and learning, writing code becomes easier. But, as we advance in our careers, it becomes equally important to learn how to maintain and help others maintain what we are writing. 1. Single Responsibility Principle Easy to understand. Every module, class, or function should only have a single responsibility or only one reason to change. But itâ€™s difficult to practically implement because lines can get blurry during implementation.</description>
    </item>
    
    
  </channel>
</rss>
